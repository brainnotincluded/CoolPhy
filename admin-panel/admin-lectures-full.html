<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin: Create Lecture (Full Editor) - CoolPhy</title>

    <!-- KaTeX CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

    <!-- TikZJax -->
    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>

    <!-- Monaco Editor -->
    <link rel="stylesheet" data-name="vs/editor/editor.main" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/editor/editor.main.min.css">

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Source+Serif+Pro:wght@400;600&family=Kalam:wght@400;700&display=swap" rel="stylesheet">

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            color: #d4d4d4;
            overflow: hidden;
        }

        header {
            padding: 15px 20px;
            background: #252526;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 { font-size: 20px; font-weight: 600; }

        .header-actions { display: flex; gap: 10px; }

        .btn {
            padding: 6px 12px;
            background: #0e639c;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }

        .btn:hover { background: #1177bb; }

        .btn-secondary { background: #3e3e42; }
        .btn-secondary:hover { background: #505050; }

        .container { display: flex; flex: 1; overflow: hidden; }

        .editor-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #3e3e42;
            min-width: 0;
        }

        .tabs {
            display: flex;
            background: #2d2d30;
            border-bottom: 1px solid #3e3e42;
        }

        .tab {
            padding: 10px 20px;
            background: transparent;
            color: #858585;
            border: none;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }

        .tab:hover { color: #cccccc; }

        .tab.active {
            background: #1e1e1e;
            color: #ffffff;
            border-bottom: 2px solid #0e639c;
        }

        .editor-content {
            flex: 1;
            display: none;
            min-height: 0;
        }

        .editor-content.active {
            display: flex;
            flex-direction: column;
        }

        #lecture-editor-pane {
            flex: 1;
            min-height: 0;
        }

        #monaco-lecture {
            flex: 1;
            min-height: 0;
            height: 100%;
            width: 100%;
        }

        .preview-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        /* Thumbnails */
        #preview img {
            width: 250px !important;
            height: 250px !important;
            padding: 5px;
            box-sizing: border-box;
            object-fit: contain;
            display: inline-block;
            margin: 5px;
            vertical-align: middle;
        }

        #preview svg {
            width: 100%;
            height: auto;
            max-height: calc(100vh - 160px);
            object-fit: contain;
            display: block;
            margin: 10px auto;
        }

        #preview iframe {
            width: 100%;
            max-height: calc(100vh - 160px);
            display: block;
            margin: 10px auto;
            border: none;
        }

        .pane-header {
            padding: 10px 20px;
            background: #2d2d30;
            border-bottom: 1px solid #3e3e42;
            font-size: 13px;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #preview {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #1e1e1e;
        }

        .info-text {
            font-size: 12px;
            color: #858585;
            margin-top: 5px;
        }

        .upload-status {
            font-size: 12px;
            margin-top: 6px;
            color: #cccccc;
        }

        #video-preview {
            width: 100%;
            max-height: 320px;
            border-radius: 4px;
            margin-top: 12px;
            display: none;
            background: #000;
        }

        .tikz-toolbar {
            padding: 10px;
            background: #252526;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .tool-btn {
            padding: 8px 12px;
            background: #3e3e42;
            color: #cccccc;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .tool-btn.active { background: #0e639c; color: white; }
        .tool-btn:hover { background: #505050; }

        #tikz-canvas-container {
            flex: 1;
            position: relative;
            background: #1e1e1e;
            overflow: auto;
        }

        #tikz-canvas {
            position: absolute;
            background: white;
            cursor: crosshair;
            touch-action: none;
        }

        .tikz-controls {
            padding: 10px;
            background: #252526;
            border-top: 1px solid #3e3e42;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group { display: flex; gap: 5px; align-items: center; }
        .control-group label { font-size: 12px; color: #cccccc; }
        .control-group input, .control-group select {
            padding: 4px 8px;
            background: #3e3e42;
            color: #cccccc;
            border: 1px solid #555;
            border-radius: 3px;
            font-size: 12px;
        }

        #jsxgraph-board {
            flex: 1;
            background: white;
            margin: 20px;
            border-radius: 4px;
        }

        .graph-controls {
            padding: 15px 20px;
            background: #252526;
            border-top: 1px solid #3e3e42;
        }

        .input-row { display: flex; gap: 10px; margin-bottom: 10px; align-items: center; }
        .input-row input {
            flex: 1;
            padding: 6px 10px;
            background: #3e3e42;
            color: #cccccc;
            border: 1px solid #555;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .error {
            color: #f48771;
            padding: 10px;
            background: #5a1d1d;
            border-radius: 4px;
            margin: 10px;
            font-family: monospace;
            font-size: 12px;
        }

        .code-output {
            background: #1e1e1e;
            padding: 15px;
            margin: 10px;
            border-radius: 4px;
            border: 1px solid #3e3e42;
        }

        .code-output pre {
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            white-space: pre-wrap;
        }

        .settings-group h2 { margin-bottom: 15px; font-size: 18px; color: #ffffff; }
        .settings-group label { font-size: 13px; color: #ccc; display:block; margin-bottom: 6px; }
        .settings-group input, .settings-group select, .settings-group textarea {
            width: 100%; padding: 8px; background:#1e1e1e; color:#d4d4d4; border:1px solid #3e3e42; border-radius:4px; font-size:13px;
        }

        #save-message { margin-top:15px; padding:12px; border-radius:4px; display:none; font-size:13px; }
    </style>
</head>
<body>
<header>
    <h1>üéì Create Lecture (Full Editor)</h1>
    <div class="header-actions">
        <button class="btn" id="save-lecture-btn" style="background:#107c10;">üíæ Save Lecture</button>
        <button class="btn" id="export-pdf">Export PDF</button>
        <button class="btn btn-secondary" id="export-latex">Export LaTeX</button>
        <button class="btn btn-secondary" id="copy-code">Copy Code</button>
        <a href="index.html" class="btn btn-secondary" style="text-decoration:none;display:inline-block;">‚Üê Dashboard</a>
        <a href="auth.html" class="btn btn-secondary" id="login-link" style="text-decoration:none;display:inline-block;">Login</a>
        <button class="btn btn-secondary" id="logout-btn" style="display:none;">Logout</button>
    </div>
</header>

<div class="container">
    <div class="editor-pane">
        <div class="tabs">
            <button class="tab active" data-tab="lecture-editor">Lecture</button>
            <button class="tab" data-tab="tikz-visual">TikZ Visual</button>
            <button class="tab" data-tab="jsxgraph">Graph Plotter</button>
            <button class="tab" data-tab="lecture-settings">Lecture Settings</button>
        </div>

        <!-- Lecture LaTeX Editor -->
        <div id="lecture-editor" class="editor-content active">
            <div id="monaco-lecture"></div>
        </div>

        <!-- TikZ Visual Editor (same tools as tasks) -->
        <div id="tikz-visual" class="editor-content">
            <div class="tikz-toolbar">
                <button class="tool-btn active" data-tool="select">Select</button>
                <button class="tool-btn" data-tool="line">Line</button>
                <button class="tool-btn" data-tool="arrow">Arrow</button>
                <button class="tool-btn" data-tool="rectangle">Rectangle</button>
                <button class="tool-btn" data-tool="circle">Circle</button>
                <button class="tool-btn" data-tool="text">Text</button>
                <button class="tool-btn" data-tool="node">Node</button>
                <button class="tool-btn" data-tool="curve">Curve</button>
                <button class="tool-btn" data-tool="eraser">Eraser</button>
                <button class="tool-btn" id="toggle-touch">Touch: Off</button>
                <button class="tool-btn" id="undo-btn" title="Undo (Cmd+Z)">‚Ü∫ Undo</button>
                <button class="tool-btn" id="redo-btn" title="Redo (Cmd+Shift+Z)">‚Üª Redo</button>
                <button class="tool-btn" id="zoom-in" title="Zoom In (+)">+</button>
                <button class="tool-btn" id="zoom-out" title="Zoom Out (-)">-</button>
                <button class="tool-btn" id="zoom-reset" title="Reset Zoom">100%</button>
                <button class="tool-btn" id="fullscreen-btn" title="Fullscreen">‚õ∂</button>
                <select id="template-select" class="tool-btn" style="padding:6px 8px;">
                    <option value="">Add template‚Ä¶</option>
                    <option value="surface-solid">Solid surface</option>
                    <option value="surface-water">Water surface</option>
                    <option value="spring">Spring</option>
                    <option value="pulley-fixed">Pulley (fixed)</option>
                    <option value="pulley-movable">Pulley (movable)</option>
                    <option value="balloon">Balloon</option>
                </select>
            </div>
            <div id="tikz-canvas-container">
                <canvas id="tikz-canvas" width="1600" height="1200" style="width:800px;height:600px;"></canvas>
            </div>
            <div class="tikz-controls">
                <div class="control-group">
                    <label>Stroke:</label>
                    <input type="color" id="stroke-color" value="#000000">
                </div>
                <div class="control-group">
                    <label>Width:</label>
                    <input type="number" id="stroke-width" value="1" min="0.5" max="10" step="0.5" style="width: 60px;">
                </div>
                <div class="control-group">
                    <label>Fill:</label>
                    <input type="color" id="fill-color" value="#ffffff">
                </div>
                <button class="btn btn-secondary" id="clear-tikz">Clear</button>
                <button class="btn" id="generate-tikz">Generate TikZ</button>
            </div>
        </div>

        <!-- JSXGraph Plotter -->
        <div id="jsxgraph" class="editor-content">
            <div id="jsxgraph-board"></div>
            <div class="graph-controls">
                <div class="input-row">
                    <input type="text" id="function-input" placeholder="Enter function: f(x) = x^2, sin(x), etc.">
                    <button class="btn" id="plot-function">Plot</button>
                </div>
                <div class="input-row">
                    <label>Points:</label>
                    <input type="text" id="point-input" placeholder="(x, y) e.g., (2, 3)">
                    <button class="btn" id="add-point">Add Point</button>
                    <button class="btn btn-secondary" id="clear-graph">Clear</button>
                </div>
            </div>
        </div>

        <!-- Lecture Settings -->
        <div id="lecture-settings" class="editor-content">
            <div class="settings-group" style="padding:20px;overflow-y:auto;height:100%;">
                <h2>Lecture Settings</h2>
                <div class="form-group">
                    <label for="lecture-title">Title *</label>
                    <input type="text" id="lecture-title" placeholder="Lecture title">
                </div>
                <div class="form-group">
                    <label for="lecture-subject">Subject *</label>
                    <select id="lecture-subject">
                        <option value="">Select subject</option>
                        <option value="physics">Physics</option>
                        <option value="math">Mathematics</option>
                        <option value="cs">Computer Science</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="lecture-summary">Summary</label>
                    <textarea id="lecture-summary" rows="3" placeholder="Short description of lecture"></textarea>
                </div>
                <div class="form-group">
                    <label for="lecture-tags">Tags (comma-separated)</label>
                    <input type="text" id="lecture-tags" placeholder="quantum, interference, advanced">
                </div>
                <div class="form-group">
                    <label for="lecture-level">Level *</label>
                    <select id="lecture-level">
                        <option value="basic">Basic</option>
                        <option value="advanced">Advanced</option>
                        <option value="olympiad">Olympiad</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="lecture-status">Status *</label>
                    <select id="lecture-status">
                        <option value="draft">Draft</option>
                        <option value="active">Active</option>
                        <option value="archived">Archived</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="video-file">Upload Lecture Video</label>
                    <input type="file" id="video-file" accept="video/mp4,video/webm,video/quicktime,video/x-m4v,video/x-msvideo">
                    <div class="info-text">MP4, MOV, WebM formats. File uploads require an admin token.</div>
                    <div class="upload-status" id="video-upload-status">No video uploaded yet.</div>
                    <video id="video-preview" controls></video>
                    <button type="button" class="btn btn-secondary" id="clear-video-btn" style="margin-top:10px;display:none;">Remove Uploaded Video</button>
                </div>
                <div class="form-group">
                    <label for="video-url">External Video URL (optional)</label>
                    <input type="text" id="video-url" placeholder="https://youtube.com/...">
                    <div class="info-text">Use this if the lecture is hosted on YouTube/Vimeo/CDN.</div>
                </div>
                <div class="form-group">
                    <label for="video-transcript">Video Transcript</label>
                    <textarea id="video-transcript" rows="3"></textarea>
                </div>
                <div id="save-message"></div>
            </div>
        </div>
    </div>

    <div class="preview-pane">
        <div class="pane-header">
            <span>Lecture Preview</span>
            <button class="btn btn-secondary" id="refresh-preview">Refresh</button>
        </div>
        <div id="preview"></div>
    </div>
</div>

<!-- KaTeX -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

<!-- jsPDF + html2canvas for exports -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

<!-- JSXGraph -->
<script src="https://cdn.jsdelivr.net/npm/jsxgraph@1.7.0/distrib/jsxgraphcore.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsxgraph@1.7.0/distrib/jsxgraph.css">

<!-- Monaco -->
<script>var require = { paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' } };</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/editor/editor.main.nls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/editor/editor.main.js"></script>

<script>
    const API_BASE = 'http://178.255.127.62/api/v1';
    const API_HOST = API_BASE.replace(/\/api\/v1$/, '');

    let monacoEditor;
    let currentTab = 'lecture-editor';
    let tikzObjects = [];
    let tikzHistory = [];
    let tikzHistoryIndex = -1;
    let tikzScale = 1;
    let tikzOffsetX = 0;
    let tikzOffsetY = 0;
    let tikzCanvasWidth = 800;
    let tikzCanvasHeight = 600;
    let selectedIndex = null;
    let dragInfo = null;
    let jsxBoard;
    let uploadedVideoMeta = null;

    require(['vs/editor/editor.main'], function () {
        monacoEditor = monaco.editor.create(document.getElementById('monaco-lecture'), {
            value: `% Lecture conspect with LaTeX

\\section{–í–≤–µ–¥–µ–Ω–∏–µ –≤ –∫–≤–∞–Ω—Ç–æ–≤—É—é –º–µ—Ö–∞–Ω–∏–∫—É}

–ö–≤–∞–Ω—Ç–æ–≤–∞—è –º–µ—Ö–∞–Ω–∏–∫–∞ –∏–∑—É—á–∞–µ—Ç –ø–æ–≤–µ–¥–µ–Ω–∏–µ –º–∏–∫—Ä–æ—Å–∫–æ–ø–∏—á–µ—Å–∫–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤.`,
            language: 'latex',
            theme: 'vs-dark',
            automaticLayout: true,
            minimap: { enabled: false },
            fontSize: 14,
            lineNumbers: 'on',
            scrollBeyondLastLine: false
        });

        monacoEditor.onDidChangeModelContent(() => {
            if (currentTab === 'lecture-editor') debounceRender();
        });

        renderLatex();
    });

    const tabs = document.querySelectorAll('.tab');
    const editorContents = document.querySelectorAll('.editor-content');

    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const targetId = tab.dataset.tab;
            currentTab = targetId;

            tabs.forEach(t => t.classList.remove('active'));
            editorContents.forEach(ec => ec.classList.remove('active'));

            tab.classList.add('active');
            document.getElementById(targetId).classList.add('active');

            if (targetId === 'jsxgraph' && !jsxBoard) initJSXGraph();
            if (targetId === 'tikz-visual') renderTikzPreview();
            if (targetId === 'lecture-editor') renderLatex();
        });
    });

    let renderTimeout;
    function debounceRender() {
        clearTimeout(renderTimeout);
        renderTimeout = setTimeout(renderLatex, 300);
    }

    function renderLatex() {
        if (!monacoEditor) return;
        const code = monacoEditor.getValue();
        const preview = document.getElementById('preview');
        preview.innerHTML = '';

        try {
            const docMatch = code.match(/\\begin\{document\}([\s\S]*?)\\end\{document\}/);
            let content = docMatch ? docMatch[1] : code;
            const raw = content;
            const contentStartOffset = code.indexOf(raw);

            const mathTokens = [];
            const regexes = [
                {re: /\$\$([\s\S]*?)\$\$/g},
                {re: /\\\[([\s\S]*?)\\\]/g},
                {re: /\\\(([\s\S]*?)\\\)/g},
                {re: /(^|[^$])\$([^$\n]+?)\$(?!\$)/g, adjust: (m)=>({start:m.index+(m[1]?m[1].length:0), end:m.index+m[0].length})}
            ];
            for (const {re, adjust} of regexes) {
                const matches = [...raw.matchAll(re)];
                for (const m of matches) {
                    let s = m.index;
                    let e = m.index + m[0].length;
                    if (adjust) {
                        const adj = adjust(m);
                        s = adj.start;
                        e = adj.end;
                    }
                    mathTokens.push({start: contentStartOffset + s, end: contentStartOffset + e});
                }
            }

            content = raw.replace(/^%\s*tikz-(?:preview|layout).*$/gm, '');

            const wrapMacros = (src, macroMap) => {
                let all = [];
                for (const [macro, tag] of macroMap) {
                    const matches = [...src.matchAll(new RegExp(`\\\\${macro}\\{([^}]+)\\}`, 'g'))];
                    for (const m of matches) {
                        all.push({start:m.index, end:m.index+m[0].length, tag, inner:m[1], fullMatch:m[0]});
                    }
                }
                all.sort((a,b)=>a.start-b.start);
                let out = '';
                let pos = 0;
                for (const t of all) {
                    out += content.slice(pos, t.start);
                    const offset = contentStartOffset + raw.indexOf(t.fullMatch);
                    out += `<${t.tag} class="src" data-start="${offset}" data-end="${offset + t.fullMatch.length}">${t.inner}</${t.tag}>`;
                    pos = t.end;
                }
                out += content.slice(pos);
                return out;
            };
            content = wrapMacros(raw, [['section','h2'], ['subsection','h3'], ['textbf','strong'], ['textit','em']]);

            const tempDiv = document.createElement('div');
            function hashCode(str){let h=0;for(let i=0;i<str.length;i++){h=((h<<5)-h)+str.charCodeAt(i);h|=0}return Math.abs(h)}
            const preTikz = [...raw.matchAll(/\\begin\{tikzpicture\}[\s\S]*?\\end\{tikzpicture\}/g)].map(m=>({code:m[0],start:contentStartOffset+m.index,end:contentStartOffset+m.index+m[0].length}));
            let tikzIdx = 0;
            const tikzMatches = [];
            content = content.replace(/(\\begin\{tikzpicture\}[\s\S]*?\\end\{tikzpicture\})/g, (match, _g1, offset) => {
                const id = 'tikz-' + hashCode(match);
                const current = content;
                const before = current.slice(0, offset);
                const lineStart = before.lastIndexOf('\n') + 1;
                const prevLine = before.slice(lineStart).trim();
                let meta = {};
                const metaMatch = prevLine.match(/^%\s*tikz-(?:preview|layout)\s*:\s*(.+)$/i);
                if (metaMatch) {
                    metaMatch[1].split(',').forEach(pair => {
                        const [k,v] = pair.split('=').map(s=>s.trim());
                        if (!k) return;
                        const key = k.toLowerCase();
                        if (key === 'width') {
                            const n = parseInt((v||'').replace('%',''),10);
                            if (!isNaN(n)) meta.width = Math.max(20, Math.min(100, n));
                        }
                        if (key === 'align') {
                            const a = (v||'').toLowerCase();
                            if (['inline','center','left','right'].includes(a)) meta.align = a;
                        }
                    });
                }
                const saved = JSON.parse(localStorage.getItem('tikz_cfg_'+id) || '{}');
                const width = (meta.width != null ? meta.width : (saved.width || 100));
                const height = meta.height || saved.height;
                const align = meta.align || saved.align || 'inline';
                let alignStyle = '';
                if (align === 'inline') alignStyle = 'display:inline-block;';
                if (align === 'center') alignStyle = 'display:block;margin-left:auto;margin-right:auto;';
                if (align === 'left') alignStyle = 'display:block;margin-left:0;margin-right:auto;';
                if (align === 'right') alignStyle = 'display:block;margin-left:auto;margin-right:0;';
                const pre = preTikz[tikzIdx++] || {start:contentStartOffset, end:contentStartOffset+match.length};
                tikzMatches.push({ id, code: match, start: pre.start, end: pre.end, height });
                return `<div class="tikz-card" data-id="${id}" data-start="${pre.start}" data-end="${pre.end}" style="width:${width}%;${alignStyle}"><div id="${id}" class="tikz-frame"${height ? ` style="height:${height}px"` : ''}></div></div>`;
            });

            tempDiv.innerHTML = content;
            preview.appendChild(tempDiv);

            renderMathInElement(preview, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\[', right: '\\]', display: true},
                    {left: '\\(', right: '\\)', display: false}
                ],
                throwOnError: false
            });

            const katexElements = preview.querySelectorAll('.katex');
            let mathIdx = 0;
            katexElements.forEach(el => {
                if (mathIdx < mathTokens.length) {
                    const token = mathTokens[mathIdx++];
                    el.classList.add('src');
                    el.dataset.start = token.start;
                    el.dataset.end = token.end;
                }
            });

            tikzMatches.forEach(({ id, code, height }) => {
                const container = document.getElementById(id);
                const card = document.querySelector(`.tikz-card[data-id="${id}"]`);
                if (!container || !card) return;
                card.style.margin = '8px';
                const iframe = document.createElement('iframe');
                iframe.style.width = '100%';
                iframe.style.border = '0';
                iframe.loading = 'lazy';
                const html = '<!DOCTYPE html><html><head>' +
                              '<meta charset="utf-8">' +
                              '<link rel="stylesheet" href="https://tikzjax.com/v1/fonts.css">' +
                              '<script defer src="https://tikzjax.com/v1/tikzjax.js"><\/script>' +
                              '<style>html,body{margin:0;padding:0;height:100%;background:#fff;display:flex;align-items:center;justify-content:center;}svg{max-width:240px;max-height:240px;width:auto;height:auto;}</style>' +
                              '</head><body>' +
                              '<script type="text/tikz">' + code + '<\/script>' +
                              '</body></html>';
                iframe.srcdoc = html;
                iframe.onload = () => {
                    const adjust = () => {
                        try {
                            const doc = iframe.contentDocument;
                            const h = Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight, 150);
                            iframe.style.height = (height ? height : h) + 'px';
                        } catch (e) {}
                    };
                    adjust();
                    const interval = setInterval(adjust, 300);
                    setTimeout(() => clearInterval(interval), 5000);
                };
                container.innerHTML = '';
                container.appendChild(iframe);
            });

            let decorations = [];
            const offsetToPos = (text, off) => {
                const s = text.slice(0, off).split('\n');
                return { line: s.length, col: s[s.length-1].length + 1 };
            };
            const highlight = (start, end) => {
                if (!monacoEditor) return;
                const s = offsetToPos(code, start);
                const e = offsetToPos(code, end);
                decorations = monacoEditor.deltaDecorations(decorations, [{
                    range: new monaco.Range(s.line, s.col, e.line, e.col),
                    options: { inlineClassName: 'code-highlight' }
                }]);
            };
            const clearHighlight = () => {
                if (!monacoEditor) return;
                decorations = monacoEditor.deltaDecorations(decorations, []);
            };
            preview.addEventListener('mouseover', (ev) => {
                const el = ev.target.closest('[data-start][data-end]');
                if (!el) return;
                highlight(parseInt(el.dataset.start,10), parseInt(el.dataset.end,10));
            });
            preview.addEventListener('mouseout', (ev) => {
                const el = ev.target.closest('[data-start][data-end]');
                if (!el) return;
                clearHighlight();
            });
        } catch (error) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = 'Error: ' + error.message;
            preview.appendChild(errorDiv);
        }
    }

    document.getElementById('refresh-preview').addEventListener('click', renderLatex);

    const tikzCanvas = document.getElementById('tikz-canvas');
    const tikzCtx = tikzCanvas.getContext('2d', { alpha: false });
    const dpr = window.devicePixelRatio || 1;

    function resizeTikzCanvas() {
        const container = document.getElementById('tikz-canvas-container');
        if (!container) return;
        const rect = container.getBoundingClientRect();
        tikzCanvasWidth = rect.width || 800;
        tikzCanvasHeight = rect.height || 600;
        tikzCanvas.width = tikzCanvasWidth * dpr;
        tikzCanvas.height = tikzCanvasHeight * dpr;
        tikzCanvas.style.width = tikzCanvasWidth + 'px';
        tikzCanvas.style.height = tikzCanvasHeight + 'px';
        renderTikzCanvas();
    }
    window.addEventListener('resize', resizeTikzCanvas);

    function screenToWorld(clientX, clientY) {
        const rect = tikzCanvas.getBoundingClientRect();
        const canvasX = clientX - rect.left;
        const canvasY = clientY - rect.top;
        const w = tikzCanvasWidth;
        const h = tikzCanvasHeight;
        const x = (canvasX - w/2) / tikzScale - tikzOffsetX + w/2;
        const y = (canvasY - h/2) / tikzScale - tikzOffsetY + h/2;
        return { x, y };
    }

    function findNearestObject(x, y, maxDist = 20) {
        let bestIndex = null;
        let bestDist = maxDist;
        tikzObjects.forEach((obj, idx) => {
            const d = distanceToShape(obj, x, y);
            if (d < bestDist) {
                bestDist = d;
                bestIndex = idx;
            }
        });
        return bestIndex;
    }

    function snapPoint(x, y, ignoreIndex = null) {
        const snapDist = 10;
        let bestX = x;
        let bestY = y;
        let bestD = snapDist;
        tikzObjects.forEach((obj, idx) => {
            if (idx === ignoreIndex) return;
            switch (obj.type) {
                case 'line':
                case 'arrow': {
                    const pts = [ {x: obj.x1, y: obj.y1}, {x: obj.x2, y: obj.y2} ];
                    pts.forEach(p => {
                        const d = Math.hypot(x - p.x, y - p.y);
                        if (d < bestD) { bestD = d; bestX = p.x; bestY = p.y; }
                    });
                    break;
                }
                case 'circle': {
                    const d = Math.hypot(x - obj.x, y - obj.y);
                    if (d < bestD) { bestD = d; bestX = obj.x; bestY = obj.y; }
                    break;
                }
                case 'rectangle': {
                    const corners = [
                        {x: obj.x, y: obj.y},
                        {x: obj.x + obj.width, y: obj.y},
                        {x: obj.x, y: obj.y + obj.height},
                        {x: obj.x + obj.width, y: obj.y + obj.height},
                    ];
                    corners.forEach(p => {
                        const d = Math.hypot(x - p.x, y - p.y);
                        if (d < bestD) { bestD = d; bestX = p.x; bestY = p.y; }
                    });
                    break;
                }
                case 'text':
                case 'node': {
                    const d = Math.hypot(x - obj.x, y - obj.y);
                    if (d < bestD) { bestD = d; bestX = obj.x; bestY = obj.y; }
                    break;
                }
            }
        });
        return { x: bestX, y: bestY };
    }

    let currentTool = 'select';
    let isDrawing = false;
    let startX, startY;
    let touchAllowed = false;

    document.getElementById('toggle-touch').addEventListener('click', () => {
        touchAllowed = !touchAllowed;
        document.getElementById('toggle-touch').textContent = 'Touch: ' + (touchAllowed ? 'On' : 'Off');
    });

    function saveHistory() {
        tikzHistoryIndex++;
        tikzHistory = tikzHistory.slice(0, tikzHistoryIndex);
        tikzHistory.push(JSON.parse(JSON.stringify(tikzObjects)));
    }
    function undo() {
        if (tikzHistoryIndex > 0) {
            tikzHistoryIndex--;
            tikzObjects = JSON.parse(JSON.stringify(tikzHistory[tikzHistoryIndex]));
            renderTikzCanvas();
        }
    }
    function redo() {
        if (tikzHistoryIndex < tikzHistory.length - 1) {
            tikzHistoryIndex++;
            tikzObjects = JSON.parse(JSON.stringify(tikzHistory[tikzHistoryIndex]));
            renderTikzCanvas();
        }
    }
    document.getElementById('undo-btn').addEventListener('click', undo);
    document.getElementById('redo-btn').addEventListener('click', redo);

    document.addEventListener('keydown', (e) => {
        if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
            e.preventDefault();
            undo();
        } else if ((e.metaKey || e.ctrlKey) && e.key === 'z' && e.shiftKey) {
            e.preventDefault();
            redo();
        }
    });

    function setZoom(scale) {
        tikzScale = Math.max(0.1, Math.min(10, scale));
        renderTikzCanvas();
        document.getElementById('zoom-reset').textContent = Math.round(tikzScale * 100) + '%';
    }
    document.getElementById('zoom-in').addEventListener('click', () => setZoom(tikzScale * 1.2));
    document.getElementById('zoom-out').addEventListener('click', () => setZoom(tikzScale / 1.2));
    document.getElementById('zoom-reset').addEventListener('click', () => {
        setZoom(1);
        tikzOffsetX = 0;
        tikzOffsetY = 0;
        renderTikzCanvas();
    });
    tikzCanvas.addEventListener('wheel', (e) => {
        if (e.metaKey || e.ctrlKey) {
            e.preventDefault();
            setZoom(tikzScale * (e.deltaY < 0 ? 1.1 : 0.9));
        }
    });

    let isPanning = false;
    let panStartX, panStartY;
    tikzCanvas.addEventListener('mousedown', (e) => {
        if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
            isPanning = true;
            panStartX = e.offsetX;
            panStartY = e.offsetY;
            e.preventDefault();
        }
    });
    tikzCanvas.addEventListener('mousemove', (e) => {
        if (isPanning) {
            tikzOffsetX += (e.offsetX - panStartX) / tikzScale;
            tikzOffsetY += (e.offsetY - panStartY) / tikzScale;
            panStartX = e.offsetX;
            panStartY = e.offsetY;
            renderTikzCanvas();
        }
    });
    tikzCanvas.addEventListener('mouseup', () => { isPanning = false; });

    document.getElementById('fullscreen-btn').addEventListener('click', () => {
        const tikzTab = document.getElementById('tikz-visual');
        if (!document.fullscreenElement) {
            tikzTab.requestFullscreen().catch(() => {});
        } else {
            document.exitFullscreen();
        }
    });
    document.addEventListener('fullscreenchange', resizeTikzCanvas);

    const toolButtons = document.querySelectorAll('.tool-btn[data-tool]');
    toolButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            toolButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentTool = btn.dataset.tool;
        });
    });

    const pointerDown = (e) => {
        if (e.pointerType === 'touch' && !touchAllowed) return;
        if (isPanning) return;

        if (currentTool === 'select') {
            const { x, y } = screenToWorld(e.clientX, e.clientY);
            const idx = findNearestObject(x, y, 20);
            if (idx === null) {
                selectedIndex = null;
                dragInfo = null;
                renderTikzCanvas();
                return;
            }
            selectedIndex = idx;
            const obj = tikzObjects[idx];
            const handleRadius = 10;
            let handle = null;
            if (obj.type === 'line' || obj.type === 'arrow') {
                const d1 = Math.hypot(x - obj.x1, y - obj.y1);
                const d2 = Math.hypot(x - obj.x2, y - obj.y2);
                if (d1 < handleRadius && d1 <= d2) handle = 'line-start';
                else if (d2 < handleRadius) handle = 'line-end';
            } else if (obj.type === 'circle') {
                const d = Math.hypot(x - obj.x, y - obj.y);
                if (d < handleRadius) handle = 'circle-center';
            }
            if (handle) {
                dragInfo = { mode: 'handle', handle, index: idx };
            } else {
                dragInfo = { mode: 'move', index: idx, startX: x, startY: y, original: JSON.parse(JSON.stringify(obj)) };
            }
            renderTikzCanvas();
            return;
        }

        if (e.button === 1 || e.shiftKey) return;
        const { x, y } = screenToWorld(e.clientX, e.clientY);
        startX = x;
        startY = y;
        isDrawing = true;
        if (currentTool === 'text') {
            const text = prompt('Enter text:');
            if (text) {
                tikzObjects.push({ type: 'text', x: startX, y: startY, text, color: document.getElementById('stroke-color').value });
                renderTikzCanvas();
                saveHistory();
            }
            isDrawing = false;
        }
    };
    tikzCanvas.addEventListener('pointerdown', pointerDown);

    const pointerMove = (e) => {
        if (e.pointerType === 'touch' && !touchAllowed) return;
        if (isPanning) return;

        if (currentTool === 'select') {
            if (!dragInfo) return;
            const { x, y } = screenToWorld(e.clientX, e.clientY);
            const obj = tikzObjects[dragInfo.index];
            if (!obj) return;
            if (dragInfo.mode === 'handle') {
                const snapped = snapPoint(x, y, dragInfo.index);
                if (dragInfo.handle === 'line-start') {
                    obj.x1 = snapped.x; obj.y1 = snapped.y;
                } else if (dragInfo.handle === 'line-end') {
                    obj.x2 = snapped.x; obj.y2 = snapped.y;
                } else if (dragInfo.handle === 'circle-center') {
                    obj.x = snapped.x; obj.y = snapped.y;
                }
            } else if (dragInfo.mode === 'move') {
                const dx = x - dragInfo.startX;
                const dy = y - dragInfo.startY;
                const base = dragInfo.original;
                switch (base.type) {
                    case 'line':
                    case 'arrow':
                        obj.x1 = base.x1 + dx; obj.y1 = base.y1 + dy;
                        obj.x2 = base.x2 + dx; obj.y2 = base.y2 + dy;
                        break;
                case 'rectangle':
                case 'circle':
                case 'text':
                case 'node':
                    obj.x = base.x + dx;
                    obj.y = base.y + dy;
                    break;
                }
            }
            renderTikzCanvas();
            return;
        }

        if (!isDrawing) return;
        const { x: currentX, y: currentY } = screenToWorld(e.clientX, e.clientY);
        renderTikzCanvas();
        tikzCtx.save();
        tikzCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        tikzCtx.translate(tikzCanvasWidth/2, tikzCanvasHeight/2);
        tikzCtx.scale(tikzScale, tikzScale);
        tikzCtx.translate(-tikzCanvasWidth/2 + tikzOffsetX, -tikzCanvasHeight/2 + tikzOffsetY);
        tikzCtx.strokeStyle = document.getElementById('stroke-color').value;
        tikzCtx.lineWidth = document.getElementById('stroke-width').value / tikzScale;
        tikzCtx.fillStyle = document.getElementById('fill-color').value;
        switch (currentTool) {
            case 'line':
                tikzCtx.beginPath(); tikzCtx.moveTo(startX, startY); tikzCtx.lineTo(currentX, currentY); tikzCtx.stroke();
                break;
            case 'arrow':
                drawArrow(tikzCtx, startX, startY, currentX, currentY); break;
            case 'rectangle':
                tikzCtx.strokeRect(startX, startY, currentX - startX, currentY - startY); break;
            case 'circle':
                const radius = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2));
                tikzCtx.beginPath(); tikzCtx.arc(startX, startY, radius, 0, 2 * Math.PI); tikzCtx.stroke();
                break;
        }
        tikzCtx.restore();
    };
    tikzCanvas.addEventListener('pointermove', pointerMove);

    const pointerUp = (e) => {
        if (e.pointerType === 'touch' && !touchAllowed) return;
        if (isPanning) return;

        if (currentTool === 'select') {
            if (dragInfo) {
                saveHistory();
                dragInfo = null;
            }
            return;
        }

        if (!isDrawing) return;
        const { x: endX, y: endY } = screenToWorld(e.clientX, e.clientY);
        const strokeColor = document.getElementById('stroke-color').value;
        const strokeWidth = document.getElementById('stroke-width').value;
        const fillColor = document.getElementById('fill-color').value;
        if (currentTool === 'eraser') {
            const threshold = 15;
            let erased = false;
            for (let i = tikzObjects.length - 1; i >= 0; i--) {
                if (distanceToShape(tikzObjects[i], endX, endY) <= threshold) {
                    tikzObjects.splice(i, 1);
                    erased = true;
                    break;
                }
            }
            if (erased) saveHistory();
        } else {
            switch (currentTool) {
                case 'line':
                    tikzObjects.push({ type:'line', x1:startX, y1:startY, x2:endX, y2:endY, color:strokeColor, width:strokeWidth });
                    saveHistory();
                    break;
                case 'arrow':
                    tikzObjects.push({ type:'arrow', x1:startX, y1:startY, x2:endX, y2:endY, color:strokeColor, width:strokeWidth });
                    saveHistory();
                    break;
                case 'rectangle':
                    tikzObjects.push({ type:'rectangle', x:startX, y:startY, width:endX-startX, height:endY-startY, color:strokeColor, strokeWidth:strokeWidth, fill:fillColor });
                    saveHistory();
                    break;
                case 'circle':
                    const radius = Math.sqrt(Math.pow(endX-startX,2)+Math.pow(endY-startY,2));
                    tikzObjects.push({ type:'circle', x:startX, y:startY, radius, color:strokeColor, strokeWidth:strokeWidth, fill:fillColor });
                    saveHistory();
                    break;
                case 'node':
                    const nodeText = prompt('Enter node text:');
                    if (nodeText) {
                        tikzObjects.push({ type:'node', x:startX, y:startY, text:nodeText, color:strokeColor });
                        saveHistory();
                    }
                    break;
            }
        }
        isDrawing = false;
        renderTikzCanvas();
    };
    tikzCanvas.addEventListener('pointerup', pointerUp);
    tikzCanvas.addEventListener('pointercancel', pointerUp);

    function drawArrow(ctx, fromX, fromY, toX, toY) {
        const headlen = 10;
        const angle = Math.atan2(toY - fromY, toX - fromX);
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(toX, toY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
        ctx.stroke();
    }

    function distanceToShape(obj, px, py) {
        function distPointToSegment(x1, y1, x2, y2, x0, y0) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            if (dx === 0 && dy === 0) return Math.hypot(x0 - x1, y0 - y1);
            const t = ((x0 - x1) * dx + (y0 - y1) * dy) / (dx * dx + dy * dy);
            const clamped = Math.max(0, Math.min(1, t));
            const nx = x1 + clamped * dx;
            const ny = y1 + clamped * dy;
            return Math.hypot(x0 - nx, y0 - ny);
        }
        switch (obj.type) {
            case 'line':
            case 'arrow':
                return distPointToSegment(obj.x1, obj.y1, obj.x2, obj.y2, px, py);
            case 'rectangle': {
                const left = obj.x;
                const right = obj.x + obj.width;
                const top = obj.y;
                const bottom = obj.y + obj.height;
                const dx = Math.max(left - px, 0, px - right);
                const dy = Math.max(top - py, 0, py - bottom);
                return Math.hypot(dx, dy);
            }
            case 'circle':
                return Math.abs(Math.hypot(px - obj.x, py - obj.y) - obj.radius);
            case 'text':
            case 'node':
                return Math.hypot(px - obj.x, py - obj.y);
            default:
                return Infinity;
        }
    }

    saveHistory();
    resizeTikzCanvas();

    function renderTikzCanvas() {
        const w = tikzCanvasWidth;
        const h = tikzCanvasHeight;
        tikzCtx.save();
        tikzCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        tikzCtx.fillStyle = 'white';
        tikzCtx.fillRect(0, 0, w, h);
        tikzCtx.translate(w/2, h/2);
        tikzCtx.scale(tikzScale, tikzScale);
        tikzCtx.translate(-w/2 + tikzOffsetX, -h/2 + tikzOffsetY);
        tikzCtx.strokeStyle = '#f0f0f0';
        tikzCtx.lineWidth = 0.5 / tikzScale;
        for (let i = 0; i < w * 2; i += 20) {
            tikzCtx.beginPath();
            tikzCtx.moveTo(i - w, -h);
            tikzCtx.lineTo(i - w, h * 2);
            tikzCtx.stroke();
        }
        for (let i = 0; i < h * 2; i += 20) {
            tikzCtx.beginPath();
            tikzCtx.moveTo(-w, i - h);
            tikzCtx.lineTo(w * 2, i - h);
            tikzCtx.stroke();
        }
        tikzObjects.forEach((obj, idx) => {
            tikzCtx.strokeStyle = obj.color || '#000';
            tikzCtx.lineWidth = (obj.strokeWidth || obj.width || 1) / tikzScale;
            tikzCtx.fillStyle = obj.fill || 'transparent';
            switch (obj.type) {
                case 'line':
                    tikzCtx.beginPath();
                    tikzCtx.moveTo(obj.x1, obj.y1);
                    tikzCtx.lineTo(obj.x2, obj.y2);
                    tikzCtx.stroke();
                    break;
                case 'arrow':
                    drawArrow(tikzCtx, obj.x1, obj.y1, obj.x2, obj.y2);
                    break;
                case 'rectangle':
                    tikzCtx.strokeRect(obj.x, obj.y, obj.width, obj.height);
                    break;
                case 'circle':
                    tikzCtx.beginPath();
                    tikzCtx.arc(obj.x, obj.y, obj.radius, 0, 2 * Math.PI);
                    tikzCtx.stroke();
                    break;
                case 'text':
                case 'node':
                    tikzCtx.fillStyle = obj.color;
                    tikzCtx.font = (14 / tikzScale) + 'px Arial';
                    tikzCtx.fillText(obj.text, obj.x, obj.y);
                    break;
            }
            if (idx === selectedIndex) {
                tikzCtx.save();
                tikzCtx.fillStyle = '#0e639c';
                const handleSize = 4 / tikzScale;
                if (obj.type === 'line' || obj.type === 'arrow') {
                    const handles = [ {x: obj.x1, y: obj.y1}, {x: obj.x2, y: obj.y2} ];
                    handles.forEach(p => {
                        tikzCtx.fillRect(p.x - handleSize, p.y - handleSize, handleSize*2, handleSize*2);
                    });
                } else if (obj.type === 'circle') {
                    tikzCtx.fillRect(obj.x - handleSize, obj.y - handleSize, handleSize*2, handleSize*2);
                }
                tikzCtx.restore();
            }
        });
        tikzCtx.restore();
    }

    function renderTikzPreview() {
        const preview = document.getElementById('preview');
        preview.innerHTML = '<div class="code-output"><h3>TikZ Code:</h3><pre>' + generateTikZCode() + '</pre></div>';
    }

    document.getElementById('clear-tikz').addEventListener('click', () => {
        tikzObjects = [];
        saveHistory();
        renderTikzCanvas();
    });

    document.getElementById('generate-tikz').addEventListener('click', renderTikzPreview);

    const templateSelect = document.getElementById('template-select');
    templateSelect.addEventListener('change', () => {
        const t = templateSelect.value;
        if (!t) return;
        templateSelect.value = '';
        const cw = tikzCanvasWidth;
        const ch = tikzCanvasHeight;
        const cx = cw / 2, cy = ch / 2;
        if (t === 'surface-solid') {
            tikzObjects.push({ type:'rectangle', x:20, y:cy+40, width:cw-40, height:8, color:'#666', strokeWidth:2, fill:'#666' });
        } else if (t === 'surface-water') {
            const seg=40; const amp=6; const y=cy+40; let pts=[];
            for(let i=20;i<cw-20;i+=seg){ pts.push({x:i,y:y+Math.sin(i/10)*amp}); }
            for(let i=0;i<pts.length-1;i++){ tikzObjects.push({ type:'line', x1:pts[i].x, y1:pts[i].y, x2:pts[i+1].x, y2:pts[i+1].y, color:'#1e90ff', width:2 }); }
        } else if (t === 'spring') {
            const x0=100,y0=cy, turns=10, pitch=10, amp=10; let prev={x:x0,y:y0};
            for(let i=1;i<=turns;i++){ const x=x0+i*pitch; const y=y0+(i%2?amp:-amp); tikzObjects.push({ type:'line', x1:prev.x, y1:prev.y, x2:x, y2:y, color:'#888', width:2 }); prev={x,y}; }
        } else if (t === 'pulley-fixed') {
            tikzObjects.push({ type:'circle', x:cx-40, y:cy-20, radius:20, color:'#444', strokeWidth:2, fill:'#eee' });
            tikzObjects.push({ type:'circle', x:cx+40, y:cy-20, radius:20, color:'#444', strokeWidth:2, fill:'#eee' });
            tikzObjects.push({ type:'line', x1:cx-40, y1:cy-40, x2:cx+40, y2:cy-40, color:'#444', width:3 });
        } else if (t === 'pulley-movable') {
            tikzObjects.push({ type:'circle', x:cx, y:cy-20, radius:22, color:'#444', strokeWidth:2, fill:'#eee' });
            tikzObjects.push({ type:'circle', x:cx, y:cy+60, radius:22, color:'#444', strokeWidth:2, fill:'#eee' });
            tikzObjects.push({ type:'line', x1:cx, y1:cy-42, x2:cx, y2:cy+38, color:'#444', width:3 });
        } else if (t === 'balloon') {
            tikzObjects.push({ type:'circle', x:cx, y:cy, radius:30, color:'#ff4d4f', strokeWidth:2, fill:'#ff6b6d' });
            tikzObjects.push({ type:'line', x1:cx, y1:cy+30, x2:cx, y2:cy+80, color:'#ff6b6d', width:2 });
        }
        renderTikzCanvas();
    });

    function generateTikZCode() {
        let code = '\\begin{tikzpicture}[scale=0.1]\\n';
        tikzObjects.forEach(obj => {
            const x1 = (obj.x1 / 10).toFixed(2);
            const y1 = (obj.y1 / 10).toFixed(2);
            const x2 = (obj.x2 / 10).toFixed(2);
            const y2 = (obj.y2 / 10).toFixed(2);
            const x = (obj.x / 10).toFixed(2);
            const y = (obj.y / 10).toFixed(2);
            switch (obj.type) {
                case 'line':
                    code += `  \\draw (${x1},${y1}) -- (${x2},${y2});\\n`;
                    break;
                case 'arrow':
                    code += `  \\draw[->,thick] (${x1},${y1}) -- (${x2},${y2});\\n`;
                    break;
                case 'rectangle':
                    const w = (obj.width / 10).toFixed(2);
                    const h = (obj.height / 10).toFixed(2);
                    code += `  \\draw (${x},${y}) rectangle +(${w},${h});\\n`;
                    break;
                case 'circle':
                    const r = (obj.radius / 10).toFixed(2);
                    code += `  \\draw (${x},${y}) circle (${r});\\n`;
                    break;
                case 'text':
                    code += `  \\node at (${x},${y}) {${obj.text}};\\n`;
                    break;
                case 'node':
                    code += `  \\node[draw] at (${x},${y}) {${obj.text}};\\n`;
                    break;
            }
        });
        code += '\\end{tikzpicture}';
        return code;
    }

    function initJSXGraph() {
        if (jsxBoard) return;
        const boardDiv = document.getElementById('jsxgraph-board');
        if (!boardDiv) return;
        jsxBoard = JXG.JSXGraph.initBoard('jsxgraph-board', {
            boundingbox: [-10, 10, 10, -10],
            axis: true,
            showNavigation: true,
            showCopyright: false
        });
    }

    document.getElementById('plot-function').addEventListener('click', () => {
        if (!jsxBoard) initJSXGraph();
        const funcInput = document.getElementById('function-input').value;
        try {
            let expr = funcInput.replace(/f\(x\)\s*=\s*/, '');
            expr = expr.replace(/\^/g, '**');
            jsxBoard.create('functiongraph', [
                function(x) { return eval(expr); }
            ], {strokeColor: '#' + Math.floor(Math.random()*16777215).toString(16)});
            document.getElementById('function-input').value = '';
        } catch (e) {
            alert('Error plotting function: ' + e.message);
        }
    });

    document.getElementById('add-point').addEventListener('click', () => {
        if (!jsxBoard) initJSXGraph();
        const pointInput = document.getElementById('point-input').value;
        const match = pointInput.match(/\(([^,]+),([^)]+)\)/);
        if (match) {
            const x = parseFloat(match[1]);
            const y = parseFloat(match[2]);
            jsxBoard.create('point', [x, y], {name: `(${x},${y})`});
            document.getElementById('point-input').value = '';
        }
    });

    document.getElementById('clear-graph').addEventListener('click', () => {
        if (jsxBoard) {
            JXG.JSXGraph.freeBoard(jsxBoard);
            jsxBoard = null;
            initJSXGraph();
        }
    });

    const exportLatexBtn = document.getElementById('export-latex');
    if (exportLatexBtn) {
        exportLatexBtn.addEventListener('click', () => {
            if (!monacoEditor) return;
            const code = monacoEditor.getValue();
            const blob = new Blob([code], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'lecture.tex';
            a.click();
            URL.revokeObjectURL(url);
        });
    }

    const copyCodeBtn = document.getElementById('copy-code');
    if (copyCodeBtn) {
        copyCodeBtn.addEventListener('click', () => {
            if (!monacoEditor) return;
            navigator.clipboard.writeText(monacoEditor.getValue());
            alert('LaTeX copied to clipboard!');
        });
    }

    const exportPdfBtn = document.getElementById('export-pdf');
    if (exportPdfBtn) {
        exportPdfBtn.addEventListener('click', async () => {
            const { jsPDF } = window.jspdf;
            const preview = document.getElementById('preview');
            const clone = preview.cloneNode(true);
            const liveIframes = preview.querySelectorAll('.tikz-frame iframe');
            const cloneIframes = clone.querySelectorAll('.tikz-frame iframe');
            for (let i = 0; i < liveIframes.length; i++) {
                const live = liveIframes[i];
                const doc = live.contentDocument;
                if (doc) {
                    const svg = doc.querySelector('svg');
                    if (svg) {
                        const ser = new XMLSerializer();
                        const svgStr = ser.serializeToString(svg);
                        const img = document.createElement('img');
                        img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgStr);
                        img.style.width = live.style.width || '100%';
                        cloneIframes[i].parentNode.replaceChild(img, cloneIframes[i]);
                    }
                }
            }
            const hidden = document.createElement('div');
            hidden.style.position = 'fixed';
            hidden.style.left = '-99999px';
            hidden.style.top = '0';
            hidden.appendChild(clone);
            document.body.appendChild(hidden);
            const canvas = await html2canvas(clone, { backgroundColor: '#ffffff', scale: 2, useCORS: true, foreignObjectRendering: true });
            document.body.removeChild(hidden);

            const pdf = new jsPDF('p', 'pt', 'a4');
            const pageW = pdf.internal.pageSize.getWidth();
            const pageH = pdf.internal.pageSize.getHeight();
            const margin = 24;
            const imgW = pageW - margin * 2;
            const imgH = canvas.height * imgW / canvas.width;

            let remainingH = imgH;
            let sY = 0;
            while (remainingH > 0) {
                const sliceHpx = Math.min(canvas.height - sY, (pageH - margin * 2) * canvas.width / imgW);
                const sliceCanvas = document.createElement('canvas');
                sliceCanvas.width = canvas.width;
                sliceCanvas.height = sliceHpx;
                const ctx = sliceCanvas.getContext('2d');
                ctx.drawImage(canvas, 0, sY, canvas.width, sliceHpx, 0, 0, canvas.width, sliceHpx);
                const imgData = sliceCanvas.toDataURL('image/png');
                const sliceHpt = sliceHpx * imgW / canvas.width;
                pdf.addImage(imgData, 'PNG', margin, margin, imgW, sliceHpt);
                remainingH -= sliceHpt;
                sY += sliceHpx;
                if (remainingH > 0) pdf.addPage();
            }
            pdf.save('lecture-preview.pdf');
        });
    }

    const videoFileInput = document.getElementById('video-file');
    const videoStatus = document.getElementById('video-upload-status');
    const videoPreviewEl = document.getElementById('video-preview');
    const clearVideoBtn = document.getElementById('clear-video-btn');

    if (videoFileInput) {
        videoFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            uploadVideoFile(file);
        });
    }

    if (clearVideoBtn) {
        clearVideoBtn.addEventListener('click', () => {
            resetUploadedVideo();
            if (videoFileInput) videoFileInput.value = '';
        });
    }

    function setVideoStatus(message, isError = false) {
        if (!videoStatus) return;
        videoStatus.textContent = message;
        videoStatus.style.color = isError ? '#f48771' : '#cccccc';
    }

    function resetUploadedVideo() {
        uploadedVideoMeta = null;
        setVideoStatus('No video uploaded yet.');
        if (videoPreviewEl) {
            videoPreviewEl.pause();
            videoPreviewEl.removeAttribute('src');
            videoPreviewEl.load();
            videoPreviewEl.style.display = 'none';
        }
        if (clearVideoBtn) {
            clearVideoBtn.style.display = 'none';
        }
    }

    resetUploadedVideo();

    async function uploadVideoFile(file) {
        const token = getToken();
        if (!token) {
            setVideoStatus('Please login before uploading videos.', true);
            if (videoFileInput) videoFileInput.value = '';
            return;
        }
        setVideoStatus(`Uploading ${file.name}...`);
        const formData = new FormData();
        formData.append('file', file);
        try {
            const res = await fetch(`${API_BASE}/admin/videos`, {
                method: 'POST',
                headers: { 'Authorization': 'Bearer ' + token },
                body: formData
            });
            const data = await res.json();
            if (!res.ok) {
                throw new Error(data.error || 'Upload failed');
            }
            uploadedVideoMeta = data;
            const streamURL = data.stream_url && data.stream_url.startsWith('http') ? data.stream_url : `${API_HOST}${data.stream_url}`;
            setVideoStatus(`Uploaded ${data.original_name} (${formatBytes(data.size_bytes)})`);
            if (videoPreviewEl && streamURL) {
                videoPreviewEl.src = streamURL;
                videoPreviewEl.style.display = 'block';
                videoPreviewEl.load();
            }
            if (clearVideoBtn) {
                clearVideoBtn.style.display = 'inline-block';
            }
        } catch (error) {
            setVideoStatus('Error: ' + error.message, true);
            uploadedVideoMeta = null;
            if (videoFileInput) videoFileInput.value = '';
            if (videoPreviewEl) {
                videoPreviewEl.pause();
                videoPreviewEl.removeAttribute('src');
                videoPreviewEl.load();
                videoPreviewEl.style.display = 'none';
            }
            if (clearVideoBtn) {
                clearVideoBtn.style.display = 'none';
            }
        }
    }

    function formatBytes(bytes) {
        if (bytes === 0) return '0 B';
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(1024));
        return (bytes / Math.pow(1024, i)).toFixed(1) + ' ' + sizes[i];
    }

    function getToken() { return localStorage.getItem('COOLPHY_TOKEN') || ''; }

    function setAuthUI() {
        const t = getToken();
        const logoutBtn = document.getElementById('logout-btn');
        const loginLink = document.getElementById('login-link');
        if (t) {
            logoutBtn.style.display = 'inline-block';
            loginLink.style.display = 'none';
        } else {
            logoutBtn.style.display = 'none';
            loginLink.style.display = 'inline-block';
        }
    }
    setAuthUI();

    document.getElementById('logout-btn').addEventListener('click', () => {
        localStorage.removeItem('COOLPHY_TOKEN');
        setAuthUI();
    });

    document.getElementById('save-lecture-btn').addEventListener('click', async () => {
        const token = getToken();
        if (!token) {
            showSaveMessage('Please login first (click Login in header)', true);
            return;
        }
        const title = document.getElementById('lecture-title').value.trim();
        const subject = document.getElementById('lecture-subject').value;
        if (!title || !subject) {
            showSaveMessage('Please fill required fields: Title and Subject', true);
            return;
        }
        const payload = collectLecturePayload();
        try {
            const res = await fetch(`${API_BASE}/admin/lectures`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + token
                },
                body: JSON.stringify(payload)
            });
            const result = await res.json();
            if (res.ok) {
                showSaveMessage('Lecture created successfully! ID: ' + (result.id || 'N/A'), false);
            } else {
                throw new Error(result.error || 'Failed to create lecture');
            }
        } catch (error) {
            showSaveMessage('Error: ' + error.message, true);
        }
    });

    function collectLecturePayload() {
        const tagsValue = document.getElementById('lecture-tags').value || '';
        const tags = tagsValue.split(',').map(t => t.trim()).filter(Boolean);
        const videoUrl = document.getElementById('video-url').value.trim();
        const payload = {
            title: document.getElementById('lecture-title').value.trim(),
            subject: document.getElementById('lecture-subject').value,
            content_latex: monacoEditor ? monacoEditor.getValue() : '',
            summary: document.getElementById('lecture-summary').value,
            tags,
            level: document.getElementById('lecture-level').value,
            status: document.getElementById('lecture-status').value,
            video_transcript: document.getElementById('video-transcript').value,
            video_asset_id: uploadedVideoMeta ? uploadedVideoMeta.id : null
        };
        if (videoUrl) {
            payload.video_url = videoUrl;
        }
        return payload;
    }

    function showSaveMessage(text, isError) {
        const msg = document.getElementById('save-message');
        if (!msg) return;
        msg.style.display = 'block';
        msg.style.background = isError ? '#5a1d1d' : '#107c10';
        msg.style.color = isError ? '#f48771' : '#ffffff';
        msg.textContent = text;
    }
</script>
</body>
</html>
