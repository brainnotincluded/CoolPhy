<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin: Create Task (Full Editor) - CoolPhy</title>
    
    <!-- KaTeX CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    
    <!-- TikZJax -->
    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>
    
    <!-- Monaco Editor -->
    <link rel="stylesheet" data-name="vs/editor/editor.main" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/editor/editor.main.min.css">

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Source+Serif+Pro:wght@400;600&family=Kalam:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            color: #d4d4d4;
            overflow: hidden;
        }
        
        header {
            padding: 15px 20px;
            background: #252526;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        h1 {
            font-size: 20px;
            font-weight: 600;
        }
        
        .header-actions {
            display: flex;
            gap: 10px;
        }
        
        .btn {
            padding: 6px 12px;
            background: #0e639c;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }
        
        .btn:hover {
            background: #1177bb;
        }
        
        .btn-secondary {
            background: #3e3e42;
        }
        
        .btn-secondary:hover {
            background: #505050;
        }
        
        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .editor-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #3e3e42;
            min-width: 0;
        }
        
        .tabs {
            display: flex;
            background: #2d2d30;
            border-bottom: 1px solid #3e3e42;
        }
        
        .tab {
            padding: 10px 20px;
            background: transparent;
            color: #858585;
            border: none;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }
        
        .tab:hover {
            color: #cccccc;
        }
        
        .tab.active {
            background: #1e1e1e;
            color: #ffffff;
            border-bottom: 2px solid #0e639c;
        }
        
        .editor-content {
            flex: 1;
            display: none;
            min-height: 0;
        }
        
        .editor-content.active {
            display: flex;
            flex-direction: column;
        }
        
        #monaco-editor,
        #monaco-solution,
        #monaco-hint {
            flex: 1;
            min-height: 0;
            height: 100%;
            width: 100%;
        }
        #latex-editor,
        #solution-editor,
        #hint-editor {
            flex: 1;
            min-height: 0;
        }
        
        .preview-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        
        .pane-header {
            padding: 10px 20px;
            background: #2d2d30;
            border-bottom: 1px solid #3e3e42;
            font-size: 13px;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #preview {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #1e1e1e;
        }
        
        .preview-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 8px 20px;
            background: #252526;
            border-bottom: 1px solid #3e3e42;
            font-size: 12px;
        }
        .preview-controls label { color: #ccc; }
        .preview-controls input, .preview-controls select {
            background: #3e3e42; color: #ccc; border: 1px solid #555; border-radius: 3px; padding: 4px 6px;
        }
        
        .tikz-frame {
            display: inline-block;
            vertical-align: top;
            width: 100%;
            margin: 8px;
            background: #fff;
            border-radius: 4px;
        }
        .tikz-card-ctrl {
            position: relative;
            margin-top: 4px;
            display: flex;
            gap: 8px;
            align-items: center;
            font-size: 12px;
            color: #ccc;
        }
        .tikz-card-ctrl input, .tikz-card-ctrl select {
            background: #3e3e42; color: #ccc; border: 1px solid #555; border-radius: 3px; padding: 2px 4px;
        }
        .tikz-card {
            display: inline-block;
            vertical-align: top;
            margin: 8px;
            background: transparent;
            width: 100%;
        }
        
        /* TikZ Editor */
        .tikz-toolbar {
            padding: 10px;
            background: #252526;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        .tool-btn {
            padding: 8px 12px;
            background: #3e3e42;
            color: #cccccc;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .tool-btn:hover {
            background: #505050;
        }
        
        .tool-btn.active {
            background: #0e639c;
            color: white;
        }
        
        #tikz-canvas-container {
            flex: 1;
            position: relative;
            background: #1e1e1e;
            overflow: auto;
        }
        
        #tikz-canvas-container:fullscreen {
            display: flex;
            align-items: center;
            justify-content: center;
            background: #1e1e1e;
        }
        
        #tikz-canvas-container:fullscreen #tikz-canvas {
            width: 95vw !important;
            height: 95vh !important;
        }
        
        #tikz-canvas {
            position: absolute;
            background: white;
            cursor: crosshair;
            touch-action: none; /* better Apple Pencil support */
        }
        
        .tikz-controls {
            padding: 10px;
            background: #252526;
            border-top: 1px solid #3e3e42;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .control-group label {
            font-size: 12px;
            color: #cccccc;
        }
        
        .control-group input,
        .control-group select {
            padding: 4px 8px;
            background: #3e3e42;
            color: #cccccc;
            border: 1px solid #555;
            border-radius: 3px;
            font-size: 12px;
        }
        
        /* JSXGraph */
        #jsxgraph-board {
            flex: 1;
            background: white;
            margin: 20px;
            border-radius: 4px;
        }
        
        .graph-controls {
            padding: 15px 20px;
            background: #252526;
            border-top: 1px solid #3e3e42;
        }
        
        .input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }
        
        .input-row input {
            flex: 1;
            padding: 6px 10px;
            background: #3e3e42;
            color: #cccccc;
            border: 1px solid #555;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }
        
        textarea {
            width: 100%;
            padding: 10px;
            background: #1e1e1e;
            color: #d4d4d4;
            border: 1px solid #3e3e42;
            font-family: 'Courier New', Courier, monospace;
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            min-height: 100px;
        }
        
        .error {
            color: #f48771;
            padding: 10px;
            background: #5a1d1d;
            border-radius: 4px;
            margin: 10px;
            font-family: monospace;
            font-size: 12px;
        }
        
        .code-output {
            background: #1e1e1e;
            padding: 15px;
            margin: 10px;
            border-radius: 4px;
            border: 1px solid #3e3e42;
        }
        
        .code-output pre {
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            white-space: pre-wrap;
        }
        /* Preview hover mapping */
        .src:hover, .tikz-card:hover { outline: 2px solid #0e639c; outline-offset: 2px; background: rgba(14,99,156,0.08); }
        /* Monaco highlight */
        .monaco-editor .code-highlight { background: rgba(14,99,156,0.35); border-bottom: 1px solid #0e639c; }
        
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1e1e1e;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #424242;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #4e4e4e;
        }
    </style>
</head>
<body>
    <header>
        <h1>üìù Create Task (Full Editor)</h1>
        <div class="header-actions">
            <button class="btn" id="save-task-btn" style="background:#107c10;">üíæ Save Task</button>
            <button class="btn" id="export-pdf">Export PDF</button>
            <button class="btn btn-secondary" id="copy-code">Copy Code</button>
            <a href="index.html" class="btn btn-secondary" style="text-decoration:none;display:inline-block;">‚Üê Dashboard</a>
            <a href="auth.html" class="btn btn-secondary" id="login-link" style="text-decoration:none;display:inline-block;">Login</a>
            <button class="btn btn-secondary" id="logout-btn" style="display:none;">Logout</button>
        </div>
    </header>
    
    <div class="container">
        <div class="editor-pane">
            <div class="tabs">
                <button class="tab active" data-tab="latex-editor">Description</button>
                <button class="tab" data-tab="solution-editor">Solution</button>
                <button class="tab" data-tab="hint-editor">Hint</button>
                <button class="tab" data-tab="tikz-visual">TikZ Visual</button>
                <button class="tab" data-tab="jsxgraph">Graph Plotter</button>
                <button class="tab" data-tab="task-settings">Task Settings</button>
            </div>
            
            <!-- LaTeX Editor with Monaco - Description -->
            <div id="latex-editor" class="editor-content active">
                <div id="monaco-editor"></div>
            </div>
            
            <!-- Solution Editor -->
            <div id="solution-editor" class="editor-content">
                <div id="monaco-solution"></div>
            </div>
            
            <!-- Hint Editor -->
            <div id="hint-editor" class="editor-content">
                <div id="monaco-hint"></div>
            </div>
            
            <!-- TikZ Visual Editor -->
            <div id="tikz-visual" class="editor-content">
                <div class="tikz-toolbar">
                    <button class="tool-btn active" data-tool="select">Select</button>
                    <button class="tool-btn" data-tool="line">Line</button>
                    <button class="tool-btn" data-tool="arrow">Arrow</button>
                    <button class="tool-btn" data-tool="rectangle">Rectangle</button>
                    <button class="tool-btn" data-tool="circle">Circle</button>
                    <button class="tool-btn" data-tool="text">Text</button>
                    <button class="tool-btn" data-tool="node">Node</button>
                    <button class="tool-btn" data-tool="curve">Curve</button>
                    <button class="tool-btn" id="toggle-touch">Touch: Off</button>
                    <button class="tool-btn" id="undo-btn" title="Undo (Cmd+Z)">‚Ü∫ Undo</button>
                    <button class="tool-btn" id="redo-btn" title="Redo (Cmd+Shift+Z)">‚Üª Redo</button>
                    <button class="tool-btn" id="zoom-in" title="Zoom In (+)">+</button>
                    <button class="tool-btn" id="zoom-out" title="Zoom Out (-)">-</button>
                    <button class="tool-btn" id="zoom-reset" title="Reset Zoom">100%</button>
                    <button class="tool-btn" id="fullscreen-btn" title="Fullscreen">‚õ∂</button>
                    <select id="template-select" class="tool-btn" style="padding:6px 8px;">
                        <option value="">Add template‚Ä¶</option>
                        <option value="surface-solid">Solid surface</option>
                        <option value="surface-water">Water surface</option>
                        <option value="spring">Spring</option>
                        <option value="pulley-fixed">Pulley (fixed)</option>
                        <option value="pulley-movable">Pulley (movable)</option>
                        <option value="balloon">Balloon</option>
                    </select>
                </div>
                <div id="tikz-canvas-container" style="position:relative;">
                    <canvas id="tikz-canvas" width="1600" height="1200" style="width:800px;height:600px;"></canvas>
                </div>
                <div class="tikz-controls">
                    <div class="control-group">
                        <label>Stroke:</label>
                        <input type="color" id="stroke-color" value="#000000">
                    </div>
                    <div class="control-group">
                        <label>Width:</label>
                        <input type="number" id="stroke-width" value="1" min="0.5" max="10" step="0.5" style="width: 60px;">
                    </div>
                    <div class="control-group">
                        <label>Fill:</label>
                        <input type="color" id="fill-color" value="#ffffff">
                    </div>
                    <button class="btn btn-secondary" id="clear-tikz">Clear</button>
                    <button class="btn" id="generate-tikz">Generate TikZ</button>
                </div>
            </div>
            
            <!-- JSXGraph Plotter -->
            <div id="jsxgraph" class="editor-content">
                <div id="jsxgraph-board"></div>
                <div class="graph-controls">
                    <div class="input-row">
                        <input type="text" id="function-input" placeholder="Enter function: f(x) = x^2, sin(x), etc.">
                        <button class="btn" id="plot-function">Plot</button>
                    </div>
                    <div class="input-row">
                        <label>Points:</label>
                        <input type="text" id="point-input" placeholder="(x, y) e.g., (2, 3)">
                        <button class="btn" id="add-point">Add Point</button>
                        <button class="btn btn-secondary" id="clear-graph">Clear</button>
                    </div>
                </div>
            </div>
            
            <!-- Task Settings -->
            <div id="task-settings" class="editor-content">
                <div style="padding:20px;overflow-y:auto;height:100%;">
                    <h2 style="margin-bottom:20px;font-size:18px;color:#ffffff;">Task Settings</h2>
                    <div style="margin-bottom:15px;">
                        <label style="font-size:13px;color:#ccc;display:block;margin-bottom:6px;font-weight:500;">Title *</label>
                        <input type="text" id="task-title" placeholder="Task title" style="width:100%;padding:10px;background:#1e1e1e;color:#d4d4d4;border:1px solid #3e3e42;border-radius:4px;font-size:13px;">
                    </div>
                    <div style="display:flex;gap:15px;margin-bottom:15px;">
                        <div style="flex:1;">
                            <label style="font-size:13px;color:#ccc;display:block;margin-bottom:6px;font-weight:500;">Subject *</label>
                            <select id="task-subject" style="width:100%;padding:10px;background:#1e1e1e;color:#d4d4d4;border:1px solid #3e3e42;border-radius:4px;font-size:13px;">
                                <option value="">Select subject</option>
                                <option value="physics">Physics</option>
                                <option value="math">Math</option>
                                <option value="cs">Computer Science</option>
                            </select>
                        </div>
                        <div style="flex:1;">
                            <label style="font-size:13px;color:#ccc;display:block;margin-bottom:6px;font-weight:500;">Type *</label>
                            <select id="task-type" style="width:100%;padding:10px;background:#1e1e1e;color:#d4d4d4;border:1px solid #3e3e42;border-radius:4px;font-size:13px;">
                                <option value="">Select type</option>
                                <option value="ege">–ï–ì–≠</option>
                                <option value="olympiad">Olympiad</option>
                                <option value="practice">Practice</option>
                            </select>
                        </div>
                    </div>
                    <div style="display:flex;gap:15px;margin-bottom:15px;">
                        <div style="flex:1;">
                            <label style="font-size:13px;color:#ccc;display:block;margin-bottom:6px;font-weight:500;">Level *</label>
                            <select id="task-level" style="width:100%;padding:10px;background:#1e1e1e;color:#d4d4d4;border:1px solid #3e3e42;border-radius:4px;font-size:13px;">
                                <option value="basic">Basic</option>
                                <option value="intermediate">Intermediate</option>
                                <option value="advanced">Advanced</option>
                                <option value="olympiad">Olympiad</option>
                            </select>
                        </div>
                        <div style="flex:1;">
                            <label style="font-size:13px;color:#ccc;display:block;margin-bottom:6px;font-weight:500;">Points</label>
                            <input type="number" id="task-points" value="10" min="1" max="100" style="width:100%;padding:10px;background:#1e1e1e;color:#d4d4d4;border:1px solid #3e3e42;border-radius:4px;font-size:13px;">
                        </div>
                        <div style="flex:1;">
                            <label style="font-size:13px;color:#ccc;display:block;margin-bottom:6px;font-weight:500;">Status</label>
                            <select id="task-status" style="width:100%;padding:10px;background:#1e1e1e;color:#d4d4d4;border:1px solid #3e3e42;border-radius:4px;font-size:13px;">
                                <option value="draft">Draft</option>
                                <option value="active">Active</option>
                                <option value="archived">Archived</option>
                            </select>
                        </div>
                    </div>
                    <div style="margin-bottom:15px;">
                        <label style="font-size:13px;color:#ccc;display:block;margin-bottom:6px;font-weight:500;">Tags (comma-separated)</label>
                        <input type="text" id="task-tags" placeholder="kinematics, ege-2024, projectile" style="width:100%;padding:10px;background:#1e1e1e;color:#d4d4d4;border:1px solid #3e3e42;border-radius:4px;font-size:13px;">
                    </div>
                    <div style="margin-bottom:15px;">
                        <label style="font-size:13px;color:#ccc;display:block;margin-bottom:6px;font-weight:500;">Correct Answer (for auto-checking)</label>
                        <input type="text" id="task-answer" placeholder="Enter correct answer" style="width:100%;padding:10px;background:#1e1e1e;color:#d4d4d4;border:1px solid #3e3e42;border-radius:4px;font-size:13px;">
                    </div>
                    <div id="save-message" style="margin-top:15px;padding:12px;border-radius:4px;display:none;font-size:13px;"></div>
                </div>
            </div>
        </div>
        
        <div class="preview-pane">
            <div class="pane-header">
                <span>Live Preview</span>
                <button class="btn btn-secondary" id="refresh-preview">Refresh</button>
            </div>
            <div id="preview"></div>
        </div>
    </div>
    
    <!-- KaTeX -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <!-- jsPDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- html2canvas for PDF export of preview -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    
    <!-- JSXGraph -->
    <script src="https://cdn.jsdelivr.net/npm/jsxgraph@1.7.0/distrib/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsxgraph@1.7.0/distrib/jsxgraph.css">
    
    <!-- Monaco Editor -->
    <script>var require = { paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' } };</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/editor/editor.main.nls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/editor/editor.main.js"></script>
    
    <script>
        let monacoEditor;
        let solutionEditor;
        let hintEditor;
        let currentTab = 'latex-editor';
        let tikzObjects = [];
        let tikzHistory = [];
        let tikzHistoryIndex = -1;
        let tikzScale = 1;
        let tikzOffsetX = 0;
        let tikzOffsetY = 0;
        let tikzCanvasWidth = 800;
        let tikzCanvasHeight = 600;
        let jsxBoard;
        
        // Initialize Monaco Editors
        require(['vs/editor/editor.main'], function() {
            // Description Editor
            monacoEditor = monaco.editor.create(document.getElementById('monaco-editor'), {
                value: `% Task Description

–¢–µ–ª–æ –±—Ä–æ—à–µ–Ω–æ –ø–æ–¥ —É–≥–ª–æ–º $\\alpha = 45¬∞$ –∫ –≥–æ—Ä–∏–∑–æ–Ω—Ç—É —Å –Ω–∞—á–∞–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç—å—é $v_0 = 20$ –º/—Å.

$$v_x = v_0 \\cos\\alpha$$
$$v_y = v_0 \\sin\\alpha - gt$$

–ù–∞–π–¥–∏—Ç–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É –ø–æ–¥—ä–µ–º–∞ –∏ –¥–∞–ª—å–Ω–æ—Å—Ç—å –ø–æ–ª–µ—Ç–∞.

\\begin{tikzpicture}
  \\draw[->] (0,0) -- (4,2) node[midway,above] {$v_0$};
  \\draw[dashed] (0,0) -- (4,0) node[midway,below] {$x$};
\\end{tikzpicture}`,
                language: 'latex',
                theme: 'vs-dark',
                automaticLayout: true,
                minimap: { enabled: false },
                fontSize: 14,
                lineNumbers: 'on',
                scrollBeyondLastLine: false
            });
            
            // Solution Editor
            solutionEditor = monaco.editor.create(document.getElementById('monaco-solution'), {
                value: `% Solution

\\textbf{–†–µ—à–µ–Ω–∏–µ:}

1. –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞:
$$H = \\frac{v_0^2 \\sin^2\\alpha}{2g} = \\frac{20^2 \\cdot \\sin^2 45¬∞}{2 \\cdot 10} = 10 \\text{ –º}$$

2. –î–∞–ª—å–Ω–æ—Å—Ç—å –ø–æ–ª–µ—Ç–∞:
$$L = \\frac{v_0^2 \\sin 2\\alpha}{g} = \\frac{400 \\cdot \\sin 90¬∞}{10} = 40 \\text{ –º}$$`,
                language: 'latex',
                theme: 'vs-dark',
                automaticLayout: true,
                minimap: { enabled: false },
                fontSize: 14,
                lineNumbers: 'on',
                scrollBeyondLastLine: false
            });
            
            // Hint Editor
            hintEditor = monaco.editor.create(document.getElementById('monaco-hint'), {
                value: `% Hint (optional)

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º—É–ª—ã –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è —Ç–µ–ª–∞, –±—Ä–æ—à–µ–Ω–Ω–æ–≥–æ –ø–æ–¥ —É–≥–ª–æ–º –∫ –≥–æ—Ä–∏–∑–æ–Ω—Ç—É.

–ü–æ–º–Ω–∏—Ç–µ, —á—Ç–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –¥–æ—Å—Ç–∏–≥–∞–µ—Ç—Å—è –ø—Ä–∏ $v_y = 0$.`,
                language: 'latex',
                theme: 'vs-dark',
                automaticLayout: true,
                minimap: { enabled: false },
                fontSize: 14,
                lineNumbers: 'on',
                scrollBeyondLastLine: false
            });
            
            // Auto-render on change
            monacoEditor.onDidChangeModelContent(() => {
                if (currentTab === 'latex-editor') debounceRender();
            });
            solutionEditor.onDidChangeModelContent(() => {
                if (currentTab === 'solution-editor') debounceRender();
            });
            hintEditor.onDidChangeModelContent(() => {
                if (currentTab === 'hint-editor') debounceRender();
            });
            
            // Initial render
            renderLatex();
        });
        
        // Tab switching
        const tabs = document.querySelectorAll('.tab');
        const editorContents = document.querySelectorAll('.editor-content');
        
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const targetId = tab.dataset.tab;
                currentTab = targetId;
                
                tabs.forEach(t => t.classList.remove('active'));
                editorContents.forEach(ec => ec.classList.remove('active'));
                
                tab.classList.add('active');
                document.getElementById(targetId).classList.add('active');
                
                if (targetId === 'jsxgraph' && !jsxBoard) {
                    initJSXGraph();
                }
                
                if (targetId === 'tikz-visual') {
                    renderTikzPreview();
                }
            });
        });
        
        // LaTeX rendering
        let renderTimeout;
        function debounceRender() {
            clearTimeout(renderTimeout);
            renderTimeout = setTimeout(renderLatex, 300);
        }
        
        function renderLatex() {
            let editor = monacoEditor;
            if (currentTab === 'solution-editor' && solutionEditor) editor = solutionEditor;
            if (currentTab === 'hint-editor' && hintEditor) editor = hintEditor;
            if (!editor) return;
            const code = editor.getValue();
            const preview = document.getElementById('preview');
            preview.innerHTML = '';
            
            try {
                // Extract content between \begin{document} and \end{document}
                const docMatch = code.match(/\\begin\{document\}([\s\S]*?)\\end\{document\}/);
                let content = docMatch ? docMatch[1] : code;
                
                // Compute offsets against the raw content before any replacements
                const raw = content;
                const contentStartOffset = code.indexOf(raw);
                
                // Store math token positions for later hover mapping (after KaTeX renders)
                const mathTokens = [];
                const regexes = [
                    {re: /\$\$([\s\S]*?)\$\$/g},
                    {re: /\\\[([\s\S]*?)\\\]/g},
                    {re: /\\\(([\s\S]*?)\\\)/g},
                    {re: /(^|[^$])\$([^$\n]+?)\$(?!\$)/g, adjust: (m)=>({start:m.index+(m[1]?m[1].length:0), end:m.index+m[0].length})}
                ];
                for (const {re, adjust} of regexes) {
                    const matches = [...raw.matchAll(re)];
                    for (const m of matches) {
                        let s = m.index, e = m.index + m[0].length;
                        if (adjust) { const adj = adjust(m); s = adj.start; e = adj.end; }
                        mathTokens.push({start: contentStartOffset + s, end: contentStartOffset + e, text: raw.slice(s, e)});
                    }
                }
                
                // Strip preview meta comments from rendered content
                content = raw.replace(/^%\s*tikz-(?:preview|layout).*$/gm, '');
                
                // Wrap sections/macros with proper HTML tags
                const wrapMacros = (src, macroMap) => {
                    let all = [];
                    for (const [macro, tag] of macroMap) {
                        const matches = [...src.matchAll(new RegExp(`\\\\${macro}\\{([^}]+)\\}`, 'g'))];
                        for (const m of matches) {
                            all.push({start:m.index, end:m.index+m[0].length, tag, inner:m[1], fullMatch:m[0]});
                        }
                    }
                    all.sort((a,b)=>a.start-b.start);
                    let out = '', pos = 0;
                    for (const t of all) {
                        out += content.slice(pos, t.start);
                        const offset = contentStartOffset + raw.indexOf(t.fullMatch);
                        out += `<${t.tag} class=\"src\" data-start=\"${offset}\" data-end=\"${offset + t.fullMatch.length}\">${t.inner}</${t.tag}>`;
                        pos = t.end;
                    }
                    out += content.slice(pos);
                    return out;
                };
                content = wrapMacros(raw, [['section','h2'], ['subsection','h3'], ['textbf','strong'], ['textit','em']]);
                
                const tempDiv = document.createElement('div');
                
                // Handle TikZ pictures - replace with iframes that run TikZJax inside
                function hashCode(str){let h=0;for(let i=0;i<str.length;i++){h=((h<<5)-h)+str.charCodeAt(i);h|=0}return Math.abs(h)}
                // Precompute tikz ranges from raw to keep offsets correct
                const preTikz = [...raw.matchAll(/\\begin\{tikzpicture\}[\s\S]*?\\end\{tikzpicture\}/g)].map(m=>({code:m[0],start:contentStartOffset+m.index,end:contentStartOffset+m.index+m[0].length}));
                let tikzIdx = 0;
                const tikzMatches = [];
                content = content.replace(/(\\begin\{tikzpicture\}[\s\S]*?\\end\{tikzpicture\})/g, (match, _g1, offset) => {
                    const id = 'tikz-' + hashCode(match);
                    // Parse previous line for meta like: % tikz-preview: width=50%, align=center
                    // Find the previous line from the current content (OK for reading meta)
                    const current = content;
                    const before = current.slice(0, offset);
                    const lineStart = before.lastIndexOf('\n') + 1;
                    const prevLine = before.slice(lineStart).trim();
                    let meta = {};
                    const metaMatch = prevLine.match(/^%\s*tikz-(?:preview|layout)\s*:\s*(.+)$/i);
                    if (metaMatch) {
                        metaMatch[1].split(',').forEach(pair => {
                            const [k,v] = pair.split('=').map(s=>s.trim());
                            if (!k) return; const key = k.toLowerCase();
                            if (key === 'width') { const n = parseInt((v||'').replace('%',''),10); if (!isNaN(n)) meta.width = Math.max(20, Math.min(100, n)); }
                            if (key === 'align') { const a = (v||'').toLowerCase(); if (['inline','center','left','right'].includes(a)) meta.align = a; }
                        });
                    }
                    const saved = JSON.parse(localStorage.getItem('tikz_cfg_'+id) || '{}');
                    const width = (meta.width != null ? meta.width : (saved.width || 100));
                    const height = meta.height || saved.height; // px optional
                    const align = meta.align || saved.align || 'inline';
                    let alignStyle = '';
                    if (align === 'inline') alignStyle = 'display:inline-block;';
                    if (align === 'center') alignStyle = 'display:block;margin-left:auto;margin-right:auto;';
                    if (align === 'left') alignStyle = 'display:block;margin-left:0;margin-right:auto;';
                    if (align === 'right') alignStyle = 'display:block;margin-left:auto;margin-right:0;';
                    const sel = (opt) => (opt===align ? ' selected' : '');
                    const pre = preTikz[tikzIdx++] || {start:contentStartOffset, end:contentStartOffset+match.length, code:match};
                    tikzMatches.push({ id, code: match, start: pre.start, end: pre.end, height });
                    return `<div class=\"tikz-card\" data-id=\"${id}\" data-start=\"${pre.start}\" data-end=\"${pre.end}\" style=\"width:${width}%;${alignStyle}\">`+
                           `<div id=\"${id}\" class=\"tikz-frame\" ${height?`style=\\"height:${height}px\\"`:''}></div>`+
                           `</div>`;
                });
                
                tempDiv.innerHTML = content;
                preview.appendChild(tempDiv);
                
                // Render math with KaTeX
                renderMathInElement(preview, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
                
                // After KaTeX renders, add hover attributes to math elements
                const katexElements = preview.querySelectorAll('.katex');
                let mathIdx = 0;
                katexElements.forEach(el => {
                    if (mathIdx < mathTokens.length) {
                        const token = mathTokens[mathIdx++];
                        el.classList.add('src');
                        el.dataset.start = token.start;
                        el.dataset.end = token.end;
                    }
                });
                
                // Insert iframes for TikZ diagrams
                tikzMatches.forEach(({ id, code, height }) => {
                    const container = document.getElementById(id);
                    const card = document.querySelector(`.tikz-card[data-id="${id}"]`);
                    if (!container || !card) return;
                    // default margin between cards
                    card.style.margin = '8px';
                    const iframe = document.createElement('iframe');
                    iframe.style.width = '100%';
                    iframe.style.border = '0';
                    iframe.loading = 'lazy';
                    // Build srcdoc with TikZJax
                    const escaped = code;
                    const html = '<!DOCTYPE html><html><head>' +
                                  '<meta charset="utf-8">' +
                                  '<link rel="stylesheet" href="https://tikzjax.com/v1/fonts.css">' +
                                  '<script defer src="https://tikzjax.com/v1/tikzjax.js"><\/script>' +
                                  '<style>html,body{margin:0;padding:0;background:#fff}</style>' +
                                  '</head><body>' +
                                  '<script type="text/tikz">' + escaped + '<\/script>' +
                                  '</body></html>';
                    iframe.srcdoc = html;
                    // Auto resize when content is ready
                    iframe.onload = () => {
                        const adjust = () => {
                            try {
                                const doc = iframe.contentDocument;
                                const h = Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight, 150);
                                iframe.style.height = (height ? height : h) + 'px';
                            } catch (e) {}
                        };
                        adjust();
                        const interval = setInterval(adjust, 300);
                        setTimeout(() => clearInterval(interval), 5000);
                    };
                    container.innerHTML = '';
                    container.appendChild(iframe);
                });

                // No UI controls; layout strictly from code meta

                // Hover -> highlight mapping
                let decorations = [];
                const offsetToPos = (text, off) => { const s = text.slice(0, off).split('\n'); return { line: s.length, col: s[s.length-1].length + 1 }; };
                const highlight = (start, end) => {
                    const s = offsetToPos(code, start); const e = offsetToPos(code, end);
                    decorations = monacoEditor.deltaDecorations(decorations, [{ range: new monaco.Range(s.line, s.col, e.line, e.col), options: { inlineClassName: 'code-highlight' } }]);
                };
                const clearHighlight = () => { decorations = monacoEditor.deltaDecorations(decorations, []); };
                preview.addEventListener('mouseover', (ev) => {
                    const el = ev.target.closest('[data-start][data-end]'); if (!el) return;
                    highlight(parseInt(el.dataset.start,10), parseInt(el.dataset.end,10));
                });
                preview.addEventListener('mouseout', (ev) => {
                    const el = ev.target.closest('[data-start][data-end]'); if (!el) return; clearHighlight();
                });

            } catch (error) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                errorDiv.textContent = 'Error: ' + error.message;
                preview.appendChild(errorDiv);
            }
        }
        
        // TikZ Visual Editor
        const tikzCanvas = document.getElementById('tikz-canvas');
        const tikzCtx = tikzCanvas.getContext('2d', { alpha: false });
        // High DPI support
        const dpr = window.devicePixelRatio || 1;
        
        function resizeTikzCanvas() {
            const container = document.getElementById('tikz-canvas-container');
            if (!container) return;
            const rect = container.getBoundingClientRect();
            tikzCanvasWidth = rect.width || 800;
            tikzCanvasHeight = rect.height || 600;
            tikzCanvas.width = tikzCanvasWidth * dpr;
            tikzCanvas.height = tikzCanvasHeight * dpr;
            tikzCanvas.style.width = tikzCanvasWidth + 'px';
            tikzCanvas.style.height = tikzCanvasHeight + 'px';
            renderTikzCanvas();
        }
        window.addEventListener('resize', resizeTikzCanvas);
        
        let currentTool = 'select';
        let isDrawing = false;
        let startX, startY;
        let tempShape = null;
        let touchAllowed = false;
        
        document.getElementById('toggle-touch').addEventListener('click', () => {
            touchAllowed = !touchAllowed;
            document.getElementById('toggle-touch').textContent = 'Touch: ' + (touchAllowed ? 'On' : 'Off');
        });
        
        // Undo/Redo
        function saveHistory() {
            tikzHistoryIndex++;
            tikzHistory = tikzHistory.slice(0, tikzHistoryIndex);
            tikzHistory.push(JSON.parse(JSON.stringify(tikzObjects)));
        }
        function undo() {
            if (tikzHistoryIndex > 0) {
                tikzHistoryIndex--;
                tikzObjects = JSON.parse(JSON.stringify(tikzHistory[tikzHistoryIndex]));
                renderTikzCanvas();
            }
        }
        function redo() {
            if (tikzHistoryIndex < tikzHistory.length - 1) {
                tikzHistoryIndex++;
                tikzObjects = JSON.parse(JSON.stringify(tikzHistory[tikzHistoryIndex]));
                renderTikzCanvas();
            }
        }
        document.getElementById('undo-btn').addEventListener('click', undo);
        document.getElementById('redo-btn').addEventListener('click', redo);
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            } else if ((e.metaKey || e.ctrlKey) && e.key === 'z' && e.shiftKey) {
                e.preventDefault();
                redo();
            }
        });
        
        // Zoom
        function setZoom(scale) {
            tikzScale = Math.max(0.1, Math.min(10, scale));
            renderTikzCanvas();
            document.getElementById('zoom-reset').textContent = Math.round(tikzScale * 100) + '%';
        }
        document.getElementById('zoom-in').addEventListener('click', () => setZoom(tikzScale * 1.2));
        document.getElementById('zoom-out').addEventListener('click', () => setZoom(tikzScale / 1.2));
        document.getElementById('zoom-reset').addEventListener('click', () => { setZoom(1); tikzOffsetX = 0; tikzOffsetY = 0; renderTikzCanvas(); });
        tikzCanvas.addEventListener('wheel', (e) => {
            if (e.metaKey || e.ctrlKey) {
                e.preventDefault();
                setZoom(tikzScale * (e.deltaY < 0 ? 1.1 : 0.9));
            }
        });
        
        // Pan with spacebar + drag or middle mouse
        let isPanning = false;
        let panStartX, panStartY;
        tikzCanvas.addEventListener('mousedown', (e) => {
            if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                isPanning = true;
                panStartX = e.offsetX;
                panStartY = e.offsetY;
                e.preventDefault();
            }
        });
        tikzCanvas.addEventListener('mousemove', (e) => {
            if (isPanning) {
                tikzOffsetX += (e.offsetX - panStartX) / tikzScale;
                tikzOffsetY += (e.offsetY - panStartY) / tikzScale;
                panStartX = e.offsetX;
                panStartY = e.offsetY;
                renderTikzCanvas();
            }
        });
        tikzCanvas.addEventListener('mouseup', (e) => {
            if (e.button === 1 || e.button === 0) {
                isPanning = false;
            }
        });
        
        // Fullscreen
        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            const container = document.getElementById('tikz-canvas-container');
            if (!document.fullscreenElement) {
                container.requestFullscreen().catch(err => console.error(err));
            } else {
                document.exitFullscreen();
            }
        });
        
        // Tool selection
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTool = btn.dataset.tool;
            });
        });
        
        const pointerDown = (e) => {
            if (e.pointerType === 'touch' && !touchAllowed) return; // palm rejection
            if (e.button === 1 || e.shiftKey) return; // Don't draw when panning
            if (isPanning) return;
            const rect = tikzCanvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;
            // Transform to world coordinates
            const w = tikzCanvasWidth;
            const h = tikzCanvasHeight;
            startX = (canvasX - w/2) / tikzScale - tikzOffsetX + w/2;
            startY = (canvasY - h/2) / tikzScale - tikzOffsetY + h/2;
            isDrawing = true;
            if (currentTool === 'text') {
                const text = prompt('Enter text:');
                if (text) {
                    tikzObjects.push({ type: 'text', x: startX, y: startY, text, color: document.getElementById('stroke-color').value });
                    renderTikzCanvas();
                }
                isDrawing = false;
            }
        };
        tikzCanvas.addEventListener('pointerdown', pointerDown);
        
        const pointerMove = (e) => {
            if (!isDrawing) return;
            if (e.pointerType === 'touch' && !touchAllowed) return;
            if (isPanning) return;
            const rect = tikzCanvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;
            const w = tikzCanvasWidth;
            const h = tikzCanvasHeight;
            const currentX = (canvasX - w/2) / tikzScale - tikzOffsetX + w/2;
            const currentY = (canvasY - h/2) / tikzScale - tikzOffsetY + h/2;
            renderTikzCanvas();
            tikzCtx.save();
            tikzCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            tikzCtx.translate(w/2, h/2);
            tikzCtx.scale(tikzScale, tikzScale);
            tikzCtx.translate(-w/2 + tikzOffsetX, -h/2 + tikzOffsetY);
            tikzCtx.strokeStyle = document.getElementById('stroke-color').value;
            tikzCtx.lineWidth = document.getElementById('stroke-width').value / tikzScale;
            tikzCtx.fillStyle = document.getElementById('fill-color').value;
            switch (currentTool) {
                case 'line':
                    tikzCtx.beginPath(); tikzCtx.moveTo(startX, startY); tikzCtx.lineTo(currentX, currentY); tikzCtx.stroke();
                    break;
                case 'arrow':
                    drawArrow(tikzCtx, startX, startY, currentX, currentY); break;
                case 'rectangle':
                    tikzCtx.strokeRect(startX, startY, currentX - startX, currentY - startY); break;
                case 'circle':
                    const radius = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2));
                    tikzCtx.beginPath(); tikzCtx.arc(startX, startY, radius, 0, 2 * Math.PI); tikzCtx.stroke();
                    break;
            }
            tikzCtx.restore();
        };
        tikzCanvas.addEventListener('pointermove', pointerMove);
        
        const pointerUp = (e) => {
            if (!isDrawing) return;
            if (e.pointerType === 'touch' && !touchAllowed) return;
            if (isPanning) return;
            const rect = tikzCanvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;
            const w = tikzCanvasWidth;
            const h = tikzCanvasHeight;
            const endX = (canvasX - w/2) / tikzScale - tikzOffsetX + w/2;
            const endY = (canvasY - h/2) / tikzScale - tikzOffsetY + h/2;
            const strokeColor = document.getElementById('stroke-color').value;
            const strokeWidth = document.getElementById('stroke-width').value;
            const fillColor = document.getElementById('fill-color').value;
            switch (currentTool) {
                case 'line':
                    tikzObjects.push({ type:'line', x1:startX, y1:startY, x2:endX, y2:endY, color:strokeColor, width:strokeWidth }); 
                    saveHistory();
                    break;
                case 'arrow':
                    tikzObjects.push({ type:'arrow', x1:startX, y1:startY, x2:endX, y2:endY, color:strokeColor, width:strokeWidth }); 
                    saveHistory();
                    break;
                case 'rectangle':
                    tikzObjects.push({ type:'rectangle', x:startX, y:startY, width:endX-startX, height:endY-startY, color:strokeColor, strokeWidth:strokeWidth, fill:fillColor }); 
                    saveHistory();
                    break;
                case 'circle':
                    const radius = Math.sqrt(Math.pow(endX-startX,2)+Math.pow(endY-startY,2));
                    tikzObjects.push({ type:'circle', x:startX, y:startY, radius, color:strokeColor, strokeWidth:strokeWidth, fill:fillColor }); 
                    saveHistory();
                    break;
                case 'node':
                    const nodeText = prompt('Enter node text:');
                    if (nodeText) { 
                        tikzObjects.push({ type:'node', x:startX, y:startY, text:nodeText, color:strokeColor }); 
                        saveHistory();
                    }
                    break;
            }
            isDrawing = false; renderTikzCanvas();
        };
        tikzCanvas.addEventListener('pointerup', pointerUp);
        tikzCanvas.addEventListener('pointercancel', pointerUp);
        
        function drawArrow(ctx, fromX, fromY, toX, toY) {
            const headlen = 10;
            const angle = Math.atan2(toY - fromY, toX - fromX);
            
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
        }
        
        // Initialize history after saveHistory function is defined
        saveHistory();
        
        // First canvas sizing (after DOM is ready)
        resizeTikzCanvas();
        
        function renderTikzCanvas() {
            tikzCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            tikzCtx.fillStyle = 'white';
            tikzCtx.fillRect(0, 0, w, h);
            
            // Apply zoom
            tikzCtx.translate(w/2, h/2);
            tikzCtx.scale(tikzScale, tikzScale);
            tikzCtx.translate(-w/2 + tikzOffsetX, -h/2 + tikzOffsetY);
            
            // Draw grid
            tikzCtx.strokeStyle = '#f0f0f0';
            tikzCtx.lineWidth = 0.5 / tikzScale;
            for (let i = 0; i < w * 2; i += 20) {
                tikzCtx.beginPath();
                tikzCtx.moveTo(i - w, -h);
                tikzCtx.lineTo(i - w, h * 2);
                tikzCtx.stroke();
            }
            for (let i = 0; i < h * 2; i += 20) {
                tikzCtx.beginPath();
                tikzCtx.moveTo(-w, i - h);
                tikzCtx.lineTo(w * 2, i - h);
                tikzCtx.stroke();
            }
            
            // Draw all objects
            tikzObjects.forEach(obj => {
                tikzCtx.strokeStyle = obj.color || '#000';
                tikzCtx.lineWidth = (obj.strokeWidth || obj.width || 1) / tikzScale;
                tikzCtx.fillStyle = obj.fill || 'transparent';
                
                switch (obj.type) {
                    case 'line':
                        tikzCtx.beginPath();
                        tikzCtx.moveTo(obj.x1, obj.y1);
                        tikzCtx.lineTo(obj.x2, obj.y2);
                        tikzCtx.stroke();
                        break;
                    case 'arrow':
                        drawArrow(tikzCtx, obj.x1, obj.y1, obj.x2, obj.y2);
                        break;
                    case 'rectangle':
                        tikzCtx.strokeRect(obj.x, obj.y, obj.width, obj.height);
                        break;
                    case 'circle':
                        tikzCtx.beginPath();
                        tikzCtx.arc(obj.x, obj.y, obj.radius, 0, 2 * Math.PI);
                        tikzCtx.stroke();
                        break;
                    case 'text':
                    case 'node':
                        tikzCtx.fillStyle = obj.color;
                        tikzCtx.font = (14 / tikzScale) + 'px Arial';
                        tikzCtx.fillText(obj.text, obj.x, obj.y);
                        break;
                }
            });
            tikzCtx.restore();
        }
        
        function renderTikzPreview() {
            const preview = document.getElementById('preview');
            preview.innerHTML = '<div class="code-output"><h3>TikZ Code:</h3><pre>' + generateTikZCode() + '</pre></div>';
        }
        
        document.getElementById('clear-tikz').addEventListener('click', () => {
            tikzObjects = [];
            saveHistory();
            renderTikzCanvas();
        });
        
        document.getElementById('generate-tikz').addEventListener('click', () => {
            renderTikzPreview();
        });
        
        // Templates
        const templateSelect = document.getElementById('template-select');
        templateSelect.addEventListener('change', () => {
            const t = templateSelect.value; if (!t) return; templateSelect.value='';
            const cw = tikzCanvasWidth;
            const ch = tikzCanvasHeight;
            const cx = cw / 2, cy = ch / 2;
            if (t === 'surface-solid') {
                tikzObjects.push({ type:'rectangle', x:20, y:cy+40, width:cw-40, height:8, color:'#666', strokeWidth:2, fill:'#666' });
            } else if (t === 'surface-water') {
                const seg=40; const amp=6; const y=cy+40; let pts=[]; for(let i=20;i<cw-20;i+=seg){ pts.push({x:i,y:y+Math.sin(i/10)*amp}); }
                for(let i=0;i<pts.length-1;i++){ tikzObjects.push({ type:'line', x1:pts[i].x, y1:pts[i].y, x2:pts[i+1].x, y2:pts[i+1].y, color:'#1e90ff', width:2 }); }
            } else if (t === 'spring') {
                const x0=100,y0=cy, turns=10, pitch=10, amp=10; let prev={x:x0,y:y0};
                for(let i=1;i<=turns;i++){ const x=x0+i*pitch; const y=y0+(i%2?amp:-amp); tikzObjects.push({ type:'line', x1:prev.x, y1:prev.y, x2:x, y2:y, color:'#888', width:2 }); prev={x,y}; }
            } else if (t === 'pulley-fixed') {
                tikzObjects.push({ type:'circle', x:cx-40, y:cy-20, radius:20, color:'#444', strokeWidth:2, fill:'#eee' });
                tikzObjects.push({ type:'circle', x:cx+40, y:cy-20, radius:20, color:'#444', strokeWidth:2, fill:'#eee' });
                tikzObjects.push({ type:'line', x1:cx-40, y1:cy-40, x2:cx+40, y2:cy-40, color:'#444', width:3 });
            } else if (t === 'pulley-movable') {
                tikzObjects.push({ type:'circle', x:cx, y:cy-20, radius:22, color:'#444', strokeWidth:2, fill:'#eee' });
                tikzObjects.push({ type:'circle', x:cx, y:cy+60, radius:22, color:'#444', strokeWidth:2, fill:'#eee' });
                tikzObjects.push({ type:'line', x1:cx, y1:cy-42, x2:cx, y2:cy+38, color:'#444', width:3 });
            } else if (t === 'balloon') {
                tikzObjects.push({ type:'circle', x:cx, y:cy, radius:30, color:'#ff4d4f', strokeWidth:2, fill:'#ff6b6d' });
                tikzObjects.push({ type:'line', x1:cx, y1:cy+30, x2:cx, y2:cy+80, color:'#ff6b6d', width:2 });
            }
            renderTikzCanvas();
        });
        
        function generateTikZCode() {
            let code = '\\begin{tikzpicture}[scale=0.1]\n';
            
            tikzObjects.forEach(obj => {
                const x1 = (obj.x1 / 10).toFixed(2);
                const y1 = (obj.y1 / 10).toFixed(2);
                const x2 = (obj.x2 / 10).toFixed(2);
                const y2 = (obj.y2 / 10).toFixed(2);
                const x = (obj.x / 10).toFixed(2);
                const y = (obj.y / 10).toFixed(2);
                
                switch (obj.type) {
                    case 'line':
                        code += `  \\draw (${x1},${y1}) -- (${x2},${y2});\n`;
                        break;
                    case 'arrow':
                        code += `  \\draw[->,thick] (${x1},${y1}) -- (${x2},${y2});\n`;
                        break;
                    case 'rectangle':
                        const w = (obj.width / 10).toFixed(2);
                        const h = (obj.height / 10).toFixed(2);
                        code += `  \\draw (${x},${y}) rectangle +(${w},${h});\n`;
                        break;
                    case 'circle':
                        const r = (obj.radius / 10).toFixed(2);
                        code += `  \\draw (${x},${y}) circle (${r});\n`;
                        break;
                    case 'text':
                        code += `  \\node at (${x},${y}) {${obj.text}};\n`;
                        break;
                    case 'node':
                        code += `  \\node[draw] at (${x},${y}) {${obj.text}};\n`;
                        break;
                }
            });
            
            code += '\\end{tikzpicture}';
            return code;
        }
        
        // JSXGraph
        function initJSXGraph() {
            jsxBoard = JXG.JSXGraph.initBoard('jsxgraph-board', {
                boundingbox: [-10, 10, 10, -10],
                axis: true,
                showNavigation: true,
                showCopyright: false
            });
        }
        
        document.getElementById('plot-function').addEventListener('click', () => {
            const funcInput = document.getElementById('function-input').value;
            
            try {
                // Parse f(x) = expression
                let expr = funcInput.replace(/f\(x\)\s*=\s*/, '');
                expr = expr.replace(/\^/g, '**');
                
                jsxBoard.create('functiongraph', [
                    function(x) { return eval(expr); }
                ], {strokeColor: '#' + Math.floor(Math.random()*16777215).toString(16)});
                
                document.getElementById('function-input').value = '';
            } catch (e) {
                alert('Error plotting function: ' + e.message);
            }
        });
        
        document.getElementById('add-point').addEventListener('click', () => {
            const pointInput = document.getElementById('point-input').value;
            const match = pointInput.match(/\(([^,]+),([^)]+)\)/);
            
            if (match) {
                const x = parseFloat(match[1]);
                const y = parseFloat(match[2]);
                jsxBoard.create('point', [x, y], {name: `(${x},${y})`});
                document.getElementById('point-input').value = '';
            }
        });
        
        document.getElementById('clear-graph').addEventListener('click', () => {
            if (jsxBoard) {
                JXG.JSXGraph.freeBoard(jsxBoard);
                initJSXGraph();
            }
        });
        
        // Export functions
        document.getElementById('export-latex').addEventListener('click', () => {
            const code = monacoEditor.getValue();
            const blob = new Blob([code], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'document.tex';
            a.click();
        });
        
        document.getElementById('copy-code').addEventListener('click', () => {
            navigator.clipboard.writeText(monacoEditor.getValue());
            alert('Code copied to clipboard!');
        });
        
        document.getElementById('export-pdf').addEventListener('click', async () => {
            const { jsPDF } = window.jspdf;
            const preview = document.getElementById('preview');

            // Clone preview and replace iframes with SVG images
            const clone = preview.cloneNode(true);
            const liveIframes = preview.querySelectorAll('.tikz-frame iframe');
            const cloneIframes = clone.querySelectorAll('.tikz-frame iframe');
            for (let i = 0; i < liveIframes.length; i++) {
                const live = liveIframes[i];
                const doc = live.contentDocument;
                if (doc) {
                    const svg = doc.querySelector('svg');
                    if (svg) {
                        const ser = new XMLSerializer();
                        const svgStr = ser.serializeToString(svg);
                        const img = document.createElement('img');
                        img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgStr);
                        img.style.width = live.style.width || '100%';
                        cloneIframes[i].parentNode.replaceChild(img, cloneIframes[i]);
                    }
                }
            }
            // Render clone to canvas
            const hidden = document.createElement('div');
            hidden.style.position = 'fixed'; hidden.style.left = '-99999px'; hidden.style.top = '0';
            hidden.appendChild(clone);
            document.body.appendChild(hidden);
            const canvas = await html2canvas(clone, { backgroundColor: '#ffffff', scale: 2, useCORS: true, foreignObjectRendering: true });
            document.body.removeChild(hidden);

            const pdf = new jsPDF('p', 'pt', 'a4');
            const pageW = pdf.internal.pageSize.getWidth();
            const pageH = pdf.internal.pageSize.getHeight();
            const margin = 24;
            const imgW = pageW - margin * 2;
            const imgH = canvas.height * imgW / canvas.width;

            // Split across pages if needed
            let remainingH = imgH;
            let sY = 0;
            while (remainingH > 0) {
                const sliceHpx = Math.min(canvas.height - sY, (pageH - margin * 2) * canvas.width / imgW);
                const sliceCanvas = document.createElement('canvas');
                sliceCanvas.width = canvas.width; sliceCanvas.height = sliceHpx;
                const ctx = sliceCanvas.getContext('2d');
                ctx.drawImage(canvas, 0, sY, canvas.width, sliceHpx, 0, 0, canvas.width, sliceHpx);
                const imgData = sliceCanvas.toDataURL('image/png');
                const sliceHpt = sliceHpx * imgW / canvas.width;
                pdf.addImage(imgData, 'PNG', margin, margin, imgW, sliceHpt);
                remainingH -= sliceHpt;
                sY += sliceHpx;
                if (remainingH > 0) pdf.addPage();
            }
            pdf.save('preview.pdf');
        });
        
        document.getElementById('refresh-preview').addEventListener('click', renderLatex);
        
        // Style presets and fonts
        const fontSelect = document.getElementById('font-select');
        const presetSelect = document.getElementById('style-preset');
        const applyFont = (f) => { document.body.style.fontFamily = f; };
        fontSelect.addEventListener('change', ()=> applyFont(fontSelect.value));
        presetSelect.addEventListener('change', ()=> {
            if (presetSelect.value === 'clean') applyFont('Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif');
            if (presetSelect.value === 'teacher') applyFont("'Source Serif Pro', Georgia, serif");
            if (presetSelect.value === 'hand') applyFont("Kalam, 'Comic Neue', cursive");
        });
        applyFont(fontSelect.value);
        
        // Initial canvas render
        renderTikzCanvas();

        // Auth helpers
        function getToken() { return localStorage.getItem('COOLPHY_TOKEN') || ''; }
        function setAuthUI() {
            const t = getToken();
            const logoutBtn = document.getElementById('logout-btn');
            const loginLink = document.getElementById('login-link');
            if (t) {
                logoutBtn.style.display = 'inline-block';
                loginLink.style.display = 'none';
            } else {
                logoutBtn.style.display = 'none';
                loginLink.style.display = 'inline-block';
            }
        }
        setAuthUI();
        document.getElementById('logout-btn').addEventListener('click', () => {
            localStorage.removeItem('COOLPHY_TOKEN');
            setAuthUI();
        });

        // Save Task
        document.getElementById('save-task-btn').addEventListener('click', async () => {
            const token = getToken();
            if (!token) {
                const msg = document.getElementById('save-message');
                msg.style.display = 'block';
                msg.style.background = '#5a1d1d';
                msg.style.color = '#f48771';
                msg.textContent = 'Please login first (click Login in header)';
                return;
            }
            const title = document.getElementById('task-title').value.trim();
            const subject = document.getElementById('task-subject').value;
            const type = document.getElementById('task-type').value;
            const level = document.getElementById('task-level').value;
            if (!title || !subject || !type) {
                const msg = document.getElementById('save-message');
                msg.style.display = 'block';
                msg.style.background = '#5a1d1d';
                msg.style.color = '#f48771';
                msg.textContent = 'Please fill required fields: Title, Subject, Type';
                return;
            }
            const tags = document.getElementById('task-tags').value.split(',').map(t=>t.trim()).filter(t=>t);
            const data = {
                title,
                description_latex: monacoEditor.getValue(),
                subject,
                tags,
                level,
                type,
                correct_answer: document.getElementById('task-answer').value,
                solution_latex: solutionEditor.getValue(),
                hint_latex: hintEditor.getValue(),
                points: parseInt(document.getElementById('task-points').value),
                status: document.getElementById('task-status').value
            };
            try {
                const res = await fetch('http://178.255.127.62/api/v1/admin/tasks', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + token },
                    body: JSON.stringify(data)
                });
                const result = await res.json();
                const msg = document.getElementById('save-message');
                msg.style.display = 'block';
                if (res.ok) {
                    msg.style.background = '#107c10';
                    msg.style.color = '#fff';
                    msg.textContent = 'Task created successfully! ID: ' + (result.id || 'N/A');
                } else {
                    msg.style.background = '#5a1d1d';
                    msg.style.color = '#f48771';
                    msg.textContent = 'Error: ' + (result.error || 'Failed to create task');
                }
            } catch (e) {
                const msg = document.getElementById('save-message');
                msg.style.display = 'block';
                msg.style.background = '#5a1d1d';
                msg.style.color = '#f48771';
                msg.textContent = 'Network error: ' + e.message;
            }
        });
    </script>
</body>
</html>
